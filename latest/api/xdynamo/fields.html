<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>xdynamo.fields API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>xdynamo.fields</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import dataclasses
from typing import Optional, Type, Dict, TypeVar, Generic, Union
from xmodel import Field, Converter
from xdynamo.common_types import DynKeyType
from xsentinels.default import Default
import typing_inspect
from typing import Hashable
from xsentinels.sentinel import Sentinel

T = TypeVar(&#39;T&#39;)


class _HashSentinel(Sentinel):
    pass


class _RangeSentinel(Sentinel):
    pass


Hash = Union[T, None]
&#34;&#34;&#34; Used in type-hints to wrap other type-hints to declare that it could be that
    type or `Null` value. Indicates that a value of Null could be assigned.

    You can use it like so:

    &gt;&gt;&gt; from null_type import Nullable, Null
    &gt;&gt;&gt;
    &gt;&gt;&gt; nullable_string: Nullable[str]
    &gt;&gt;&gt;
    &gt;&gt;&gt; # You can assign a `str` or a `Null` and it will be type-correct:
    &gt;&gt;&gt; nullable_string = &#34;hello!&#34;
    &gt;&gt;&gt; nullable_string = Null
&#34;&#34;&#34;

HashStr = Hash[str]


@dataclasses.dataclass
class _UnwrapResults:
    unwrapped_type: Type
    &#34;&#34;&#34; The type(s) with Hash/Range generic types filtered out.
    &#34;&#34;&#34;
    is_hash: bool = False
    is_range: bool = False


def _unwrap_generic_hash_or_range_types(type_to_unwrap: Type, /) -&gt; _UnwrapResults:
    &#34;&#34;&#34;
    Returns the first non-Null or non-None type inside the optional/Union type as
    the `unwrapped_type` result.

    If the type passed in is not an optional/nullable/union type, then set returned
    `unwrapped_type` to the type unaltered.

    Args:
        type_to_unwrap: Type to inspect and unwrap the optionality/nullability/union from.
    Returns:
        UnwrapResults: With the unwrapped_type, and if type is Nullable and/or Optional.
            If the Union has more than one none-Null/None type in it, then we will return
            a Union with the None and Null types filtered out.
    &#34;&#34;&#34;
    if not typing_inspect.is_generic_type(type_to_unwrap):
        return _UnwrapResults(type_to_unwrap)

    NoneType = type(None)
    saw_null = False
    saw_none = False
    types = []

    hint_union_sub_types = typing_inspect.get_args(type_to_unwrap)
    for sub_type in hint_union_sub_types:
        # if sub_type is NullType:
        #     saw_null = True
        #     continue

        if sub_type is NoneType:
            saw_none = True
            continue

        types.append(sub_type)

    if len(types) == 1:
        # No other non-Null/None types, use the type directly.
        unwrapped_type = types[0]
    else:
        # Construct final Union type with the None/Null filtered out.
        unwrapped_type = Union[tuple(types)]

    return UnwrapResults(unwrapped_type, is_nullable=saw_null, is_optional=saw_none)


class DynField(Field):
    dyn_key: Optional[DynKeyType] = Default

    def resolve_defaults(
            self,
            name,
            type_hint: Type,
            default_converter_map: Optional[Dict[Type, Converter]] = None,
            parent_field: &#34;DynField&#34; = None
    ):
        # pydoc3 will copy the parent-class doc-comment if left empty here;
        # that&#39;s exactly what I want so leaving doc-comment blank.
        super().resolve_defaults(
            name=name,
            type_hint=type_hint,
            default_converter_map=default_converter_map,
            parent_field=parent_field
        )

        if self.dyn_key:
            if not self.was_option_explicitly_set_by_user(&#39;include_in_repr&#39;):
                self.include_in_repr = True


class HashField(DynField):
    dyn_key = DynKeyType.hash


class RangeField(DynField):
    dyn_key = DynKeyType.range</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="xdynamo.fields.Hash"><code class="name">var <span class="ident">Hash</span></code></dt>
<dd>
<div class="desc"><p>Used in type-hints to wrap other type-hints to declare that it could be that
type or <code>Null</code> value. Indicates that a value of Null could be assigned.</p>
<p>You can use it like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from null_type import Nullable, Null
&gt;&gt;&gt;
&gt;&gt;&gt; nullable_string: Nullable[str]
&gt;&gt;&gt;
&gt;&gt;&gt; # You can assign a &lt;code&gt;str&lt;/code&gt; or a &lt;code&gt;Null&lt;/code&gt; and it will be type-correct:
&gt;&gt;&gt; nullable_string = &quot;hello!&quot;
&gt;&gt;&gt; nullable_string = Null
</code></pre></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="xdynamo.fields.DynField"><code class="flex name class">
<span>class <span class="ident">DynField</span></span>
<span>(</span><span>name: str = Default, type_hint: Type = &lt;property object&gt;, nullable: bool = Default, read_only: bool = Default, exclude: bool = Default, default: Any = Default, post_filter: Optional[xmodel.base.fields.Filter] = Default, converter: Optional[xmodel.base.fields.Converter] = Default, fget: Optional[Callable[[M], Any]] = Default, fset: Optional[Callable[[BaseModel, Any], None]] = Default, include_with_fields: Set[str] = Default, json_path: str = Default, json_path_separator: str = Default, include_in_repr: bool = Default, related_type: Optional[Type[BaseModel]] = Default, related_field_name_for_id: Optional[str] = Default, related_to_many: bool = Default, model: BaseModel = Default)</span>
</code></dt>
<dd>
<div class="desc"><p>If this is not used on a model field/attribute, the field will get the default set of
options automatically if the field has a type-hint; see topic
<a href="./#model-fields">BaseModel Fields</a>.</p>
<p>Preferred way going forward to provide additional options/configuration to BaseModel fields.</p>
<p>If you don't specify a value for a particular attribute, it will have the
<code>xsentinels.default.Default</code> value. When a Default value is encountered while constructing a
<code>xmodel.base.model.BaseModel</code>, it will resolve these Default values and assign the final
value for the field.</p>
<p>To resolve these Defaults, it will look at field on the parent BaseModel class.
If a non-Default value is defined there, it will use that for the child.
If not, then it looks at the next parent. If no non-Default value is found we then use
a value that makes sense. You can see what this is in the first line of each doc-comment.
In the future, when we start using Python 3.9 we can use type annotations (typing.Annotated)
to annotate a specific value to the Default type generically. For now it's hard-coded.</p>
<h2 id="side-notes">Side Notes</h2>
<p>Keep in mind that after the <code>.api</code> is accessed for the first time on a particular model
class, the sdk will construct the rest of the class (lazily)&hellip;
it will read and then remove/delete from the BaseModel class any type-hinted json fields
with a Field object assigned to the class. It moves these Field objects into a special
internal structure.
The class gets <code>None</code> values set on all fields after this is done.</p>
<h2 id="details-on-why-we-remove-them">Details on why we remove them:</h2>
<p>Doing this helps with <strong>getattr</strong>, as it will still be executed for fields without a value
when we create an object instance. <strong>getattr</strong> is used to support lazy lookups [via API] of
related objects. Using <strong>getattr</strong> is much faster than using the <strong>getattribute</strong> version.
So I want to keep using the <strong>getattr</strong> version if possible.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DynField(Field):
    dyn_key: Optional[DynKeyType] = Default

    def resolve_defaults(
            self,
            name,
            type_hint: Type,
            default_converter_map: Optional[Dict[Type, Converter]] = None,
            parent_field: &#34;DynField&#34; = None
    ):
        # pydoc3 will copy the parent-class doc-comment if left empty here;
        # that&#39;s exactly what I want so leaving doc-comment blank.
        super().resolve_defaults(
            name=name,
            type_hint=type_hint,
            default_converter_map=default_converter_map,
            parent_field=parent_field
        )

        if self.dyn_key:
            if not self.was_option_explicitly_set_by_user(&#39;include_in_repr&#39;):
                self.include_in_repr = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>xmodel.base.fields.Field</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="xdynamo.fields.HashField" href="#xdynamo.fields.HashField">HashField</a></li>
<li><a title="xdynamo.fields.RangeField" href="#xdynamo.fields.RangeField">RangeField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xdynamo.fields.DynField.dyn_key"><code class="name">var <span class="ident">dyn_key</span> : Optional[<a title="xdynamo.common_types.DynKeyType" href="common_types.html#xdynamo.common_types.DynKeyType">DynKeyType</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xdynamo.fields.DynField.resolve_defaults"><code class="name flex">
<span>def <span class="ident">resolve_defaults</span></span>(<span>self, name, type_hint: Type, default_converter_map: Optional[Dict[Type, xmodel.base.fields.Converter]] = None, parent_field: <a title="xdynamo.fields.DynField" href="#xdynamo.fields.DynField">DynField</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Resolves all dataclass attributes/fields on self that are still set to <code>Default</code>.
The only exception is <code>type_hint</code>. We will always use what is passed in, regardless
of if there is a parent-field with one set. This allows one on a BaseModel to easily
override the type-hint without having to create a field with an explicitly set
type_hint set on it (ie: let normal python annotated type-hint override any parent type).</p>
<p>This includes ones on subclasses [dataclass will generically tell us about all of them].
System calls this when a BaseModel class is being lazily constructed
[ie: when gets the <code>xmodel.base.model.BaseModel.api</code> attribute for the first time or
attempts to create an instance of the BaseModel for the fist time].</p>
<p>When the BaseModel class is being constructed, this method is called to resolve all
the Default values still on the instance. We do this by:</p>
<ol>
<li>We first look at parent_field object if one has been given.<ul>
<li>If ask that parent field which options where explicitly set by user and which
ones were set by resolving a <code>xsentinels.default.Default</code>. Field objects have an
internal/private var that keeps track of this.</li>
</ul>
</li>
<li>Next, figure out standard default value for option if option's current value is
current at <code>xsentinels.default.Default</code> (a default sentential value, used to detect
which values were left unset by user).</li>
</ol>
<h2 id="more-details">More Details</h2>
<p>I have Field objects keep track of which fields were not at
Default when they are resolved. This allows child Field objects
to know which values to copy into themselves and which ones
should be resolved normally via Default.</p>
<p>The goal here is to avoid copying value from Parent that
were originally resolved via Default mechanism
(and were not set explicitly by user).</p>
<p>An example of why this is handy:</p>
<p>If we have a parent model with a field of a different type vs the one on the child.
Unless the converter was explicitly set by the user we want to just use the default
converter for the different type on the child (and not use the wrong converter by default).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_defaults(
        self,
        name,
        type_hint: Type,
        default_converter_map: Optional[Dict[Type, Converter]] = None,
        parent_field: &#34;DynField&#34; = None
):
    # pydoc3 will copy the parent-class doc-comment if left empty here;
    # that&#39;s exactly what I want so leaving doc-comment blank.
    super().resolve_defaults(
        name=name,
        type_hint=type_hint,
        default_converter_map=default_converter_map,
        parent_field=parent_field
    )

    if self.dyn_key:
        if not self.was_option_explicitly_set_by_user(&#39;include_in_repr&#39;):
            self.include_in_repr = True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="xdynamo.fields.HashField"><code class="flex name class">
<span>class <span class="ident">HashField</span></span>
<span>(</span><span>name: str = Default, type_hint: Type = &lt;property object&gt;, nullable: bool = Default, read_only: bool = Default, exclude: bool = Default, default: Any = Default, post_filter: Optional[xmodel.base.fields.Filter] = Default, converter: Optional[xmodel.base.fields.Converter] = Default, fget: Optional[Callable[[M], Any]] = Default, fset: Optional[Callable[[BaseModel, Any], None]] = Default, include_with_fields: Set[str] = Default, json_path: str = Default, json_path_separator: str = Default, include_in_repr: bool = Default, related_type: Optional[Type[BaseModel]] = Default, related_field_name_for_id: Optional[str] = Default, related_to_many: bool = Default, model: BaseModel = Default)</span>
</code></dt>
<dd>
<div class="desc"><p>If this is not used on a model field/attribute, the field will get the default set of
options automatically if the field has a type-hint; see topic
<a href="./#model-fields">BaseModel Fields</a>.</p>
<p>Preferred way going forward to provide additional options/configuration to BaseModel fields.</p>
<p>If you don't specify a value for a particular attribute, it will have the
<code>xsentinels.default.Default</code> value. When a Default value is encountered while constructing a
<code>xmodel.base.model.BaseModel</code>, it will resolve these Default values and assign the final
value for the field.</p>
<p>To resolve these Defaults, it will look at field on the parent BaseModel class.
If a non-Default value is defined there, it will use that for the child.
If not, then it looks at the next parent. If no non-Default value is found we then use
a value that makes sense. You can see what this is in the first line of each doc-comment.
In the future, when we start using Python 3.9 we can use type annotations (typing.Annotated)
to annotate a specific value to the Default type generically. For now it's hard-coded.</p>
<h2 id="side-notes">Side Notes</h2>
<p>Keep in mind that after the <code>.api</code> is accessed for the first time on a particular model
class, the sdk will construct the rest of the class (lazily)&hellip;
it will read and then remove/delete from the BaseModel class any type-hinted json fields
with a Field object assigned to the class. It moves these Field objects into a special
internal structure.
The class gets <code>None</code> values set on all fields after this is done.</p>
<h2 id="details-on-why-we-remove-them">Details on why we remove them:</h2>
<p>Doing this helps with <strong>getattr</strong>, as it will still be executed for fields without a value
when we create an object instance. <strong>getattr</strong> is used to support lazy lookups [via API] of
related objects. Using <strong>getattr</strong> is much faster than using the <strong>getattribute</strong> version.
So I want to keep using the <strong>getattr</strong> version if possible.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HashField(DynField):
    dyn_key = DynKeyType.hash</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="xdynamo.fields.DynField" href="#xdynamo.fields.DynField">DynField</a></li>
<li>xmodel.base.fields.Field</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xdynamo.fields.HashField.dyn_key"><code class="name">var <span class="ident">dyn_key</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xdynamo.fields.HashField.resolve_defaults"><code class="name flex">
<span>def <span class="ident">resolve_defaults</span></span>(<span>self, name, type_hint: Type, default_converter_map: Optional[Dict[Type, xmodel.base.fields.Converter]] = None, parent_field: <a title="xdynamo.fields.DynField" href="#xdynamo.fields.DynField">DynField</a> = None)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xdynamo.fields.DynField" href="#xdynamo.fields.DynField">DynField</a></code>.<code><a title="xdynamo.fields.DynField.resolve_defaults" href="#xdynamo.fields.DynField.resolve_defaults">resolve_defaults</a></code>
</p>
<div class="desc inherited"><p>Resolves all dataclass attributes/fields on self that are still set to <code>Default</code>.
The only exception is <code>type_hint</code>. We will always use what is passed …</p></div>
</dd>
</dl>
</dd>
<dt id="xdynamo.fields.RangeField"><code class="flex name class">
<span>class <span class="ident">RangeField</span></span>
<span>(</span><span>name: str = Default, type_hint: Type = &lt;property object&gt;, nullable: bool = Default, read_only: bool = Default, exclude: bool = Default, default: Any = Default, post_filter: Optional[xmodel.base.fields.Filter] = Default, converter: Optional[xmodel.base.fields.Converter] = Default, fget: Optional[Callable[[M], Any]] = Default, fset: Optional[Callable[[BaseModel, Any], None]] = Default, include_with_fields: Set[str] = Default, json_path: str = Default, json_path_separator: str = Default, include_in_repr: bool = Default, related_type: Optional[Type[BaseModel]] = Default, related_field_name_for_id: Optional[str] = Default, related_to_many: bool = Default, model: BaseModel = Default)</span>
</code></dt>
<dd>
<div class="desc"><p>If this is not used on a model field/attribute, the field will get the default set of
options automatically if the field has a type-hint; see topic
<a href="./#model-fields">BaseModel Fields</a>.</p>
<p>Preferred way going forward to provide additional options/configuration to BaseModel fields.</p>
<p>If you don't specify a value for a particular attribute, it will have the
<code>xsentinels.default.Default</code> value. When a Default value is encountered while constructing a
<code>xmodel.base.model.BaseModel</code>, it will resolve these Default values and assign the final
value for the field.</p>
<p>To resolve these Defaults, it will look at field on the parent BaseModel class.
If a non-Default value is defined there, it will use that for the child.
If not, then it looks at the next parent. If no non-Default value is found we then use
a value that makes sense. You can see what this is in the first line of each doc-comment.
In the future, when we start using Python 3.9 we can use type annotations (typing.Annotated)
to annotate a specific value to the Default type generically. For now it's hard-coded.</p>
<h2 id="side-notes">Side Notes</h2>
<p>Keep in mind that after the <code>.api</code> is accessed for the first time on a particular model
class, the sdk will construct the rest of the class (lazily)&hellip;
it will read and then remove/delete from the BaseModel class any type-hinted json fields
with a Field object assigned to the class. It moves these Field objects into a special
internal structure.
The class gets <code>None</code> values set on all fields after this is done.</p>
<h2 id="details-on-why-we-remove-them">Details on why we remove them:</h2>
<p>Doing this helps with <strong>getattr</strong>, as it will still be executed for fields without a value
when we create an object instance. <strong>getattr</strong> is used to support lazy lookups [via API] of
related objects. Using <strong>getattr</strong> is much faster than using the <strong>getattribute</strong> version.
So I want to keep using the <strong>getattr</strong> version if possible.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RangeField(DynField):
    dyn_key = DynKeyType.range</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="xdynamo.fields.DynField" href="#xdynamo.fields.DynField">DynField</a></li>
<li>xmodel.base.fields.Field</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xdynamo.fields.RangeField.dyn_key"><code class="name">var <span class="ident">dyn_key</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xdynamo.fields.RangeField.resolve_defaults"><code class="name flex">
<span>def <span class="ident">resolve_defaults</span></span>(<span>self, name, type_hint: Type, default_converter_map: Optional[Dict[Type, xmodel.base.fields.Converter]] = None, parent_field: <a title="xdynamo.fields.DynField" href="#xdynamo.fields.DynField">DynField</a> = None)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xdynamo.fields.DynField" href="#xdynamo.fields.DynField">DynField</a></code>.<code><a title="xdynamo.fields.DynField.resolve_defaults" href="#xdynamo.fields.DynField.resolve_defaults">resolve_defaults</a></code>
</p>
<div class="desc inherited"><p>Resolves all dataclass attributes/fields on self that are still set to <code>Default</code>.
The only exception is <code>type_hint</code>. We will always use what is passed …</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="xdynamo" href="index.html">xdynamo</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="xdynamo.fields.Hash" href="#xdynamo.fields.Hash">Hash</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="xdynamo.fields.DynField" href="#xdynamo.fields.DynField">DynField</a></code></h4>
<ul class="">
<li><code><a title="xdynamo.fields.DynField.dyn_key" href="#xdynamo.fields.DynField.dyn_key">dyn_key</a></code></li>
<li><code><a title="xdynamo.fields.DynField.resolve_defaults" href="#xdynamo.fields.DynField.resolve_defaults">resolve_defaults</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="xdynamo.fields.HashField" href="#xdynamo.fields.HashField">HashField</a></code></h4>
<ul class="">
<li><code><a title="xdynamo.fields.HashField.dyn_key" href="#xdynamo.fields.HashField.dyn_key">dyn_key</a></code></li>
<li><code><a title="xdynamo.fields.HashField.resolve_defaults" href="#xdynamo.fields.HashField.resolve_defaults">resolve_defaults</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="xdynamo.fields.RangeField" href="#xdynamo.fields.RangeField">RangeField</a></code></h4>
<ul class="">
<li><code><a title="xdynamo.fields.RangeField.dyn_key" href="#xdynamo.fields.RangeField.dyn_key">dyn_key</a></code></li>
<li><code><a title="xdynamo.fields.RangeField.resolve_defaults" href="#xdynamo.fields.RangeField.resolve_defaults">resolve_defaults</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>