<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>xdynamo.client API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>xdynamo.client</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="xdynamo.client.dyn_client_options"><code class="name">var <span class="ident">dyn_client_options</span></code></dt>
<dd>
<div class="desc"><p>Proxy to the current <code><a title="xdynamo.client.DynClientOptions" href="#xdynamo.client.DynClientOptions">DynClientOptions</a></code> currently used/injected at the current moment.
Used this object use like you would use normal instance of DynClientOptions.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="xdynamo.client.DynClient"><code class="flex name class">
<span>class <span class="ident">DynClient</span></span>
<span>(</span><span>api:Â RemoteApi[M])</span>
</code></dt>
<dd>
<div class="desc"><p>Skeleton/Placeholder Class for future work, see story and the other classes in
this file for more details: <a href="https://app.clubhouse.io/xyngular/story/13989">https://app.clubhouse.io/xyngular/story/13989</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>api</code></strong></dt>
<dd>The <code>xmodel.remote.api.RemoteApi</code> object that is creating this object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DynClient(RemoteClient[M]):
    &#34;&#34;&#34;
    Skeleton/Placeholder Class for future work, see story and the other classes in
    this file for more details: https://app.clubhouse.io/xyngular/story/13989
    &#34;&#34;&#34;

    # This is only here to give IDE&#39;s a more concrete-class to use for type/code completion.
    # The type-hint is not otherwise used. That var is valid/gettable on an instance.
    # See `xmodel.remote.client.RemoteClient.api` for more details.
    api: &#39;DynApi[M]&#39;

    def delete_obj(self, obj: Union[M, DynKey], *, condition: Query = None):
        &#34;&#34;&#34;
         Attempts to delete passed in object from dynamodb table.

         If you pass in a condition, it will be evaluated on the dynamodb-service side and the
         deletes will only happen if the condition is met.
         This can help prevent race conditions if used correctly.

         If there is a batch-writer currently in use, we will try to use that to batch the deletes.

         Keep in mind that if you pass in a `condition`, we can&#39;t use the batch write.
         We will instead send of a single-item delete request with the condition attached
         (bypassing any current batch-writer that may be in use).

         Args:
            obj: Object to delete, it MUST have values for it&#39;s primary key(s)
                (no other values are required, the primary-key values are the only ones used).
            condition: Optional, if passed in we will send this as a `ConditionExpression`
                to dynamo.  You can pass in a Query, ie: the same structure that is used
                for `self.query()` and `self.scan()`.

                We will take the Query correctly format it for you into the `ConditionExpression`.

                If the condition is met, the item will be deleted.

                If the condition is NOT met, we will handle it for you by catch the exception,
                logging about it, setting error on response_state of object, and then returning.
                Conditions are generally used to help prevent race-conditions,
                ie: to prevent a deleted on purpose.

                Most of the time the intent is to ignore what the result is, it was either
                deleted or not;
                ie: it will eventually be handled in some way it if it was not deleted.

                If you want to know when a conditional delete fails, you can look at
                deleted objects `obj.api.response_state`.

                It&#39;s `had_error` will be `True`, there will be some info in `errors`,
                but also a field error with name `_conditional_check` and code `failed`
                you can easily check for via:

                `....response_state.has_field_error(&#39;_conditional_check&#39;, &#39;failed&#39;)`

                or you can use `xyn_model_dynamo.const.CONDITIONAL_CHECK_FAILED_KEY` for
                the field key.
         &#34;&#34;&#34;
        # Reset object error response state, we are try afresh.
        obj.api.response_state.reset()

        # Get the DynKey
        # If we don&#39;t get a dyn-key, check for that and raise nicer, higher-level error.
        key = obj if isinstance(obj, DynKey) else DynKey.via_obj(obj)
        params = {
            &#39;Key&#39;: key.key_as_dict(),
        }

        # To keep things simple, I am using &#39;put&#39; which replaces entire item,
        # so get all properties of item regardless if they changed or not.
        # todo: Check for primary key and raise a nicer, higher-level exception in that case.

        if not condition:
            resource = self._table_or_batch_writer()
            resource.delete_item(**params)
            return

        # Add the conditional query to the dynamodb params dict...
        # (can&#39;t batch-delete things with conditions, so we do them one at a time instead).
        self._add_conditions_from_query(
            query=condition, params=params, filter_key=&#39;ConditionExpression&#39;, consistent_read=False
        )

        try:
            self.api.table.delete_item(**params)
        except dynamodb.meta.client.exceptions.ConditionalCheckFailedException as e:
            # By default, we ignore conditional check failed, because this means we did not want
            # to delete the item on purpose; ie: it&#39;s not an error.
            # conditions are mostly used to prevent race-conditions, hence ignored by default.
            # If someone in the future ends up wanting the exception, we can have an argument
            # or some other way to indicate that we should re-raise the condition check exception.
            # See `self.delete_obj` doc comment (above) for more details.
            log.info(
                f&#34;Didn&#39;t delete dynamo obj ({obj}) due to condition not met ({condition}), &#34;
                f&#34;exception from dynamo ({e}).&#34;
            )
            state = obj.api.response_state
            state.had_error = True
            state.errors = [
                &#39;The conditional check failed, item was not deleted.&#39;,
                {&#39;conditional-check-failed-exception&#39;: e}
            ]
            state.add_field_error(field=CONDITIONAL_CHECK_FAILED_KEY, code=&#39;failed&#39;)

    def delete_objs(self, objs: Sequence[Union[M, DynKey]], condition: Query = None):
        &#34;&#34;&#34; Uses a batch-writer to put the items. Much more efficient than doing it one at a time.

            If you pass in a `condition`, the batch-writer can&#39;t be used and normal single-deletes
            will automatically be used instead.

            If you only give me one item, directly calls `delete_obj` without a batch-writer.
        &#34;&#34;&#34;
        if not objs:
            return

        if len(objs) == 1:
            self.delete_obj(obj=objs[0], condition=condition)
            return

        with _DynBatchResource.grab().current_writer(create_if_none=True):
            for i in objs:
                self.delete_obj(obj=i, condition=condition)

    # todo: Someday support an iterable for `objs`
    #  (ie: open it wider then a Sequence, ie: to support generators).
    def send_objs(
            self,
            objs: Sequence[M],
            *,
            condition: Query = None,
            url: UrlStr = None,
            send_limit: int = None
    ):
        &#34;&#34;&#34;
        Used to send any number of objects to Dynamo in as efficient a manner as possible.

        If possible, uses a batch-writer to put the items.
        It&#39;s WAY more efficient than doing it one at a time.

        If a condition is supplied, won&#39;t use a batch-writer as only one item can be put
        at a time with a condition.

        In the future at some point, will support transactions and at that point could put
        more items per-request at a time with condition(s).

        Args:
            objs: Objects to send to dynamo.
            url: Not used in Dynamo, ignore
            send_limit: Currently unused, we try to push as much as possible.

            condition: Optional, if passed in we will send this as a `ConditionExpression`
                to dynamo.  You can pass in a Query, ie: the same structure that is used
                for `self.query()` and `self.scan()`.

                We will take the Query correctly format it for you into the `ConditionExpression`.

                If the condition is met, the item will be put into table.

                If the condition is NOT met, we will handle it for you by catch the exception,
                logging about it, setting error on response_state of object, and then returning.
                Conditions are generally used to help prevent race-conditions,
                ie: to prevent a put on purpose; so we don&#39;t raise an exception.

                Most of the time the intent is to ignore what the result is, it was either
                put into table or not;
                ie: it will eventually be handled in some way it if it was not put into table.

                If you want to know when a conditional delete fails, you can look at
                deleted objects `obj.api.response_state`.

                It&#39;s `had_error` will be `True`, there will be some info in `errors`,
                but also a field error with name `_conditional_check` and code `failed`
                you can easily check for via:

                `....response_state.has_field_error(&#39;_conditional_check&#39;, &#39;failed&#39;)`

                or you can use `xdynamo.const.CONDITIONAL_CHECK_FAILED_KEY` for
                the field key.

        &#34;&#34;&#34;
        if not objs:
            return

        if len(objs) == 1:
            self._put_item(item=objs[0], condition=condition)
            return

        if condition:
            for i in objs:
                self._put_item(item=i, condition=condition)
            return

        with _DynBatchResource.grab().current_writer(create_if_none=True):
            for i in objs:
                self._put_item(item=i)

    def get(
            self,
            query: Query = None,
            *,
            top: int = None,
            fields: FieldNames = Default,
            allow_scan: bool = False,
            consistent_read: bool | DefaultType = Default,
            **dynamo_params,
    ) -&gt; Iterable[M]:
        &#34;&#34;&#34;
        This is the standard/abstract interface method that all RestClient&#39;s support.

        The idea behind this method is to figure out how to route this query in the most
        efficient manner we can do it in. If you want to guarantee a specific type of query
        you can use `DynClient.query`, etc.

        Generally, this is the best, generally method to use since it can adapt your request
        to the most efficient way to query Dynamo. The `DynApi` will use this method generally
        when it&#39;s asked to get something (for example, when using `DynApi.get_via_id`).

        For more info on how you can query, see:

        - [Advanced Queries](#advanced-queries)
            - [Examples](#examples_1)

        Here is the general process this method goes though to determine how to query dynamo
        for a given query:

        1. If provided query is empty.
              - Will paginate though all items in table efficiently; multiple items
                will be returned per-request in parallel.
                You&#39;ll get back a generator that gives you an object at time, but behind
                the scenes we are getting a page at a time from dynamo.
        2. We will try to batch it en-mass in parallel if we can.
           We can do this if one of the following is true:
              - Query only contains &#39;id&#39; key; this is because an &#39;id&#39; should have full primary key;
                meaning it will contain both hash and range key (if needed).
                You can provide a list of strings or `DynKey` objects.
                   - See `DynModel.id` for more details on how to use `str` with an &#39;id&#39;.
                   - See `DynKey` for more details on what a composite primary-key as a `str` is
                     like.
              - Table only has a hash-key (no range/sort key) and you provide nothing but
                hash-keys (ie: no other attributes in query)
        3. Next, we see if we can use a Dynamo query via `DynClient.query`.
              - This will use multiple queries if/as needed, but while minimizing the number of
                queries that are needed. Just depends on the query that is provided.
                More then one query is needed if there is more then one hash-key in the query,
                and there are other attributes you are filtering on
                (and so #2 above, batch-get, can&#39;t be used)
                Doing multiple queries is still far-faster then doing a scan.
                We return objects via the generator and only execute the second (or more)
                queries
              - In the future, this will automatically querying a Secondary Index if one is
                available.
                (Not Implemented Yet, we will add this when needed)
        4. Next, fallback to using a Global Index if one is available.
              - (Not Implemented Yet, we will do it when we need it)
        5. If that&#39;s not possible, in the future we fallback to scan operation.
            - (Not Implemented Yet; This isn&#39;t implemented currently and will raise NotImplemented.
              Scan operations can be very slow and so it&#39;s not something we really want to do
              normally... I did implement this if getting everything, but with filters/attributes
              to query on I decided to wait until we need it before implementing this currently).

        .. todo:: Implement querying via Secondary/Global indexes; Scanning with query values.
            see above for details.



        Args:
            query: Dict keys are the attribute/key names and values are what
                to filter on for that name.  Operators after double `__` work just like you
                would expect for our xyngular API&#39;s... here is an example:

                ```python
                { &#34;some_attr_name__gte&#34;: 2 }
                ```

                In this case, we look for `some_attr_name` greater than or equal to integer `2`.

                You MUST provide at least one value for the hash key of the table for right now.
                In the future, we will support doing a table-scan to support queries without
                a hash-key. But for right now it&#39;s required.

                For more information with examples see [Advanced Queries](#advanced-queries).

            top: This is supposed to only return this mean records; currently not implemented.
            fields: This is supposed to only retrieve provided field names in returned objects;
                currently not implemented.
            allow_scan: Defaults to False, which means this will raise an exception if a scan
                is required to execute your get.  Set to True to allow a scan if needed
                (it will still do a query, batch-get, etc; if it can, it only does a scan
                if there is no other choice).

                If the query is blank or None will still do a scan regardless of what you pass
                (to return all items in the table).
            consistent_read: Defaults to Model.api.structure.dyn_consistent_read,
                which can be set via class arguments when DynModel subclass is defined.

                You can use this to override the model default. True means we use consistent
                reads, otherwise false.
            **dynamo_params: Extra parameters to include on the Dynamo request(s) that are
                generated. This is 100% optional.
        Returns:

        &#34;&#34;&#34;

        if not query:
            # If no query.... just get all items via a bulk-scan.
            return self._get_all_items(consistent_read=consistent_read)

        # todo: We want basic logic in here to decide on batch_get vs query
        #       vs [eventually] dyn_scan.
        #       We sort of implement basic logic here to determin
        #       the best way to query dynamo so we have that logic mostly centralized instead
        #       of scattered everywhere. The logic is cetnered around how we will mostly be using
        #       dynamo. The times where we have exceptions, the outside world can just directly
        #       call `dyn_scan/query` them selves and customize the dynamo call more.
        #       `get` is the thing that figured out the best to this to in the general
        #       case.
        #   Future Vision of logic flow [this is not fully implemented or final yet]:
        #       1. Only have id/hash/range keys
        #           A. Have more than one id/hash/range keys.
        #               I. We can use the batch method.
        #           B. Use query
        #       2. Have id/hash + other attributes
        #           A. More than one hash
        #               I. Use several query calls.
        #           B. Only one hash
        #               I. Use single query call.
        #       3. Have no hash key, just other attributes.
        #           A. Must use `scan`.
        #               I. This is just something we will do later, don&#39;t need `scan` at moment.
        #

        query = _ProcessedQuery.process_query(query, api=self.api)
        structure = self.api.structure
        have_range_key = bool(structure.dyn_range_key_name)

        # Check to see if we only have key fields (without other filtering criteria);
        # if so we can do a batch-get, which is the fastest way to get a number of specific
        # values.  If we
        if query.contains_only_keys():
            dyn_keys = query.dyn_keys()

            # If we have no range-key, they all dyn-gets support get-batch.
            # it&#39;s only the lack of range-key, or a non &#39;eq&#39; operator for range-key
            # that would disqualify a specific DynKey.
            #
            # todo: Some of these keys could support batch-get, we might consider getting
            #   the ones that do via batch-get, get others via query?

            all_support_batch_get = True
            if have_range_key:
                for dyn_key in dyn_keys:
                    if not dyn_key.range_key:
                        all_support_batch_get = False
                        break

                    if dyn_key.range_operator and dyn_key.range_operator not in (&#39;eq&#39;, &#39;is_in&#39;):
                        all_support_batch_get = False
                        break

            # We have just DynKey&#39;s, so we can do a batch get (no other conditions/filters).
            # This will automatically batch a 100 at a time for us via a generator.
            # Dynamo will fetch these in parallel!
            # TODO: If we only have one key, use `get_item` instead of `batch_get_item`.
            if all_support_batch_get and dyn_keys:
                return self.batch_get(keys=dyn_keys, consistent_read=consistent_read)

        # If we have some sort of key(s) we can use (a hash key with an optional range key).
        if query.dyn_keys():
            # todo: Support `top` and `fields`.
            # todo: Support multiple hash-keys [one query per hash key].
            # todo: unless this table does not have a range key [no hash/range to tie].

            # We have a query that has the hash-key in it, that&#39;s good enough to use a query.
            return self.query(query=query, consistent_read=consistent_read)

        if allow_scan:
            return self.scan(query=query, consistent_read=consistent_read)

        # todo: Support &#39;scans&#39; or always raise error? Scans are very expensive.
        # todo: Support Global + Secondary Indexes
        #  (secondary indexes are partially supported now, since they require the hash-key
        #   so we would currently do a query with a filter, and scan whole hash-key/page).
        raise NotImplementedError(
            &#34;There are no hash-keys or id&#39;s in query, and I don&#39;t support auto routing to a scan &#34;
            &#34;when `allow_scan` is False, or using a global indexes at the moment. &#34;
            &#34;This is what you need to do without a hash-key/id. &#34;
            &#34;Scan operations are slow, so for being conservative to prevent accidentally doing &#34;
            &#34;one. For now you need to explicitly do them via self.scan or pass in True to the &#34;
            &#34;`allow_scan` parameter of this `get` method; unless your &#34;
            &#34;retrieving all records (ie: blank query). This may change in the future, but for &#34;
            &#34;now a scan operation requires an explicit opt-in.&#34;
            &#34;\n&#34;
            &#34;TODO: Support Global Indexes - if there is a global index &#34;
            &#34;then we should use them if query is using the global-index hash-key and other&#34;
            &#34;attributes are in global-index as well.&#34;
        )

    def batch_get(
            self, keys: Iterable[DynKey], *, consistent_read: bool | DefaultType = Default, **params: DynParams
    ) -&gt; Iterable[M]:
        &#34;&#34;&#34;
        Will fetch keys in the largest batch it can at a time it can from Dynamo;
        Dynamo will fetch each page of values in parallel!

        We split up the keys into 100 increments at a time automatically right now
        For each unique hash key in the set of keys provided, Dynamo will parallel fetch
        the keys (if two keys have the same hash but different range key, dynamo will do
        them sequentially).

        In the future, we may attempt to fetch multiple 100 blocks of keys asynchronously.
        As the returned generator/iterable is gone through to increase the speed.
        We don&#39;t do that yet.

        Args:
            keys (Iterable[DynKey]): Keys to fetch.
                Can be of any size, a generator will be returned to minimize memory use.

                .. tip:: If you pass in a `set`, we will be slightly more efficient.
                    We need to ensure the results are uniquified, if you pass a set we can skip
                    doing it.

            consistent_read: Defaults to Model.api.structure.dyn_consistent_read,
                which can be set via class arguments when DynModel subclass is defined.

                You can use this to override the model default. True means we use consistent
                reads, otherwise false.

            **params: An optional set of extra parameters to include in request to Dynamo,
                if so desired.

        Returns: An Iterable/Generator that will efficiently paginate though the results for you.

        &#34;&#34;&#34;
        structure = self.api.structure
        hash_name = structure.dyn_hash_key_name
        range_name = structure.dyn_range_key_name
        base_params = {**params}

        if consistent_read is Default:
            consistent_read = self.consistent_reads

        if not keys:
            return []

        def batch_pagination_generator(items):
            if not items:
                return xloop()

            table_name = structure.fully_qualified_table_name()

            # We want to merge our items with anything that could already be there...
            copy_params = base_params.copy()
            req_items_param = copy_params.setdefault(&#39;RequestItems&#39;, {})
            table_items = req_items_param.setdefault(table_name, {})
            if consistent_read:
                table_items[&#39;ConsistentRead&#39;] = True
            table_keys = table_items.setdefault(&#39;Keys&#39;, [])
            table_keys.extend(items)

            # batch_get_item is only available on dynamo-resource, not table-resource.
            return self._paginate_all_items_generator(
                method=&#39;batch_get_item&#39;,
                params=copy_params,
                use_table=False
            )

        # Go though all the keys and grab them 100 at a time from Dynamo.
        # Dynamo only supports a max of 100 keys at a time when doing a &#39;batch_get_item&#39;.
        items_requested = []
        have_range = bool(range_name)

        uniquified_keys = keys
        if not isinstance(keys, set):
            uniquified_keys = set(uniquified_keys)
        uniquified_keys = list(uniquified_keys)

        for i in range(0, len(uniquified_keys), 100):
            key_subset = [key.key_as_dict() for key in set(uniquified_keys[i:i + 100])]
            for x in batch_pagination_generator(list(key_subset)):
                yield x

    def _parse_keys_from_query(self, query: Query) -&gt; Optional[List[DynKey]]:
        query = _ProcessedQuery.process_query(query, api=self.api)

    def _parse_id(
            self, _id: Union[str, Iterable[str]]
    ) -&gt; List[DynKey]:
        keys = []
        if not _id:
            return keys

        api = self.api
        for current_id in xloop(_id, iterate_dicts=True):
            keys.append(DynKey(api=api, id=current_id))

        if not keys:
            return keys

        return keys

    @property
    def consistent_reads(self) -&gt; bool:
        # Check for injected default, use that if it exists.
        injected_default = dyn_client_options.consistent_read
        if injected_default is not Default:
            return injected_default

        # Otherwise use the model&#39;s default for consistent reads.
        return self.api.structure.dyn_consistent_read or False

    def query(
            self, query: Query = None, *, consistent_read: bool | DefaultType = Default, **dynamo_params: DynParams
    ) -&gt; Iterable[M]:
        &#34;&#34;&#34;
        Forces `DynClient` to use a query. If you want a way for client to automatically
        figure out the best way to execute your query, use one of these instead:

        - `DynApi.get`
        - `DynClient.get`

        For more info see:

        - [Advanced Queries](#advanced-queries)
            - [Examples](#examples_1)

        For a quick summary on how to provide query,
        see &#39;query&#39; argument doc (just a few lines down).
        But I would highly recommend looking at [Advanced Queries](#advanced-queries) for
        more details with examples!

        Args:
            api (DynApi): BaseApi object to use, this is how we know the table name, model class,
                etc.
            query (Query): You can give a simple dict here, modeled after how the standard rest-api
                query dict&#39;s work. Dict keys are the attribute/key names and values are what
                to filter on for that name.  Operators after double `__` work just like you
                would expect for our xyngular API&#39;s... here is an example:

                ```python
                { &#34;some_attr_name__gte&#34;: 2 }
                ```

                In this case, we look for `some_attr_name` greater than or equal to integer `2`.

                You MUST provide at least one value for the hash key of the table when using
                `query` or boto3/dynamo will raise an exception.

                This is an easy way to fill out `KeyConditionExpression` and/or `FilterExpression`.
                This method can figure out which attribute goes with which one and construct
                both expressions as needed.

                For more information with examples see [Advanced Queries](#advanced-queries).

            consistent_read: Defaults to Model.api.structure.dyn_consistent_read,
                which can be set via class arguments when DynModel subclass is defined.

                You can use this to override the model default. True means we use consistent
                reads, otherwise false.
            **params (DynParams): You can provide other standard boto3 query parameters here as you
                need. If you provide both dynamo_params and query, the ones in query will overwrite
                ones in dynamo_params if there is a conflict;

                The `query` param could use either a `KeyConditionExpression` or `FilterExpression`
                depending on what attributes are in the query dict.

        Yields:
            M: (DynModel subclass instances) - The next object we got from dynamo.
                This method returns a generator that will eventually go through all the results
                from dynamo in a memory-efficient manner.
        &#34;&#34;&#34;

        # todo: support in/lists as values....
        # todo: support `id`.

        structure = self.api.structure
        hash_key = structure.dyn_hash_key_name
        query = _ProcessedQuery.process_query(query, api=self.api)

        # if &#39;id&#39; in query:
        #
        #
        # hash_key in query:

        # 1. If we have &#39;id&#39;, iterate though that and get DynKey&#39;s out of them
        # 2. Look at hash/range keys and try to match them up if they are lists into DynKey&#39;s
        # 3. Considering auto-finding out if we have a list of keys and can just do batch-get

        # Query for each dyn-key we find.
        keys = query.dyn_keys()
        if not keys:
            raise XRemoteError(
                &#34;query got called with a query that had no valid DynKey&#39;s in it. &#34;
                &#34;This means we could not find any part(s) of the primary key we could use to do &#34;
                &#34;a query on (a Dynamo query requires at least a hash-key). &#34;
                &#34;&#34;
                &#34;If you have no conditions and just want to &#34;
                &#34;simply retrieve every item in the table use `DynClient.get` with no parameters. &#34;
                &#34;&#34;
                &#34;If you do have conditions/filters in query you need to do a `DynClient.dyn_scan` &#34;
                &#34;and have Dynamo scan the entire table. This will allow dynamo to evaluate your &#34;
                &#34;conditions on every item in the table.&#34;
            )

        for dyn_key in query.dyn_keys():
            params = {**dynamo_params}
            self._add_conditions_from_query(
                query=query,
                params=params,
                dyn_key=dyn_key,
                consistent_read=consistent_read,
            )

            for value in self._paginate_all_items_generator(method=&#39;query&#39;, params=params):
                yield value

    def scan(
            self, query: Query = None, *, consistent_read: bool | DefaultType = Default, **dynamo_params: DynParams
    ) -&gt; Iterable[M]:
        &#34;&#34;&#34; Scans entire table (vs doing a `DynClient.query`, which is much more efficient).
            Looks at every item in the table, evaluating `query` to filter which ones to return.
            The scanning/filtering happens on the server-side.

            If provided query is empty, will return all items in the table.
        &#34;&#34;&#34;
        params = {**dynamo_params}
        self._add_conditions_from_query(
            query=query,
            params=params,
            consistent_read=consistent_read,
        )
        return self._paginate_all_items_generator(method=&#39;scan&#39;, params=params)

    def _add_conditions_from_query(
            self,
            query: Query,
            params: DynParams,
            dyn_key: DynKey = None,
            filter_key: str = &#39;FilterExpression&#39;,
            consistent_read: bool | DefaultType = Default
    ):
        if consistent_read is Default:
            consistent_read = self.consistent_reads

        if consistent_read:
            params[&#39;ConsistentRead&#39;] = True

        if not query and not dyn_key:
            return

        query = _ProcessedQuery.process_query(query, api=self.api)
        key_names: Set[str] = set()
        api = self.api
        structure = self.api.structure

        if dyn_key:
            key_names.add(&#39;id&#39;)
            key_names.add(structure.dyn_hash_key_name)
            range_name = structure.dyn_range_key_name
            if range_name:
                key_names.add(range_name)

        def add_criterion(cond_list, condition_base, name, operator, value):
            # It just so happens the basic Django filter operators are generally named the same
            # as the ones in the boto3 dynamo library. So we grab the condition/operator
            # via the same names. _ProcessedQuery will normalize the names for us.

            # exists/not_exists don&#39;t require a &#39;value&#39; parameter,
            # so we need to interpret/parse query value ourselves and do the right thing.
            pre_lookup_operator = operator
            operator_needs_param = True
            if operator == &#39;exists&#39;:
                operator_needs_param = False
                if not bool_value(value):
                    # False value, so swap to the inverse/opposite operator.
                    operator = &#39;not_exists&#39;
            elif operator == &#39;not_exists&#39;:
                operator_needs_param = False
                if not bool_value(value):
                    # False value, so swap to the inverse/opposite operator.
                    operator = &#39;exists&#39;

            # Construct condition by allocating base, grabbing operator and assigning value.
            operator = getattr(condition_base(name), operator, None)
            condition = None
            if operator:
                field = structure.get_field(name)
                if operator_needs_param and field and field.converter:
                    value = field.converter(
                        api,
                        Converter.Direction.to_json,
                        field,
                        value
                    )

                operator_params = [value] if operator_needs_param else []
                condition = operator(*operator_params)

            # If we found a condition operator, use it.
            # Otherwise, we construct and raise a helpful error message.
            if operator is not None:
                cond_list.append(condition)
                return

            # Get all available conditions/operators from boto3 class so we can list them
            # in the exception message.
            available = [
                f for f in dir(condition_base)
                if callable(getattr(condition_base, f)) and not f.startswith(&#34;__&#34;)
            ]
            supplemental_msg = &#34;&#34;
            if condition_base is conditions.Key:
                supplemental_msg = (
                    f&#34;Attr ({name}) is part of primary key, there are reduced &#34;
                    f&#34;operators available for keys when using a query. &#34;
                    f&#34;We could route this to a &#39;scan&#39; operation, that would work.... &#34;
                    f&#34;Right now we don&#39;t automatically route this to a &#39;scan&#39; operation &#34;
                    f&#34;because that&#39;s much slower and you probably really are wanting &#34;
                    f&#34;to do a query. You can use `dyn_scan` your self directly if that&#39;s &#34;
                    f&#34;what you really want to do. Or we could implement an Option/Flag to &#34;
                    f&#34;auto-route to a scan operation when needed.&#34;
                )

            raise XRemoteError(
                f&#34;Using unknown boto3/dynamo operator ({pre_lookup_operator}), &#34;
                f&#34;for query on attr ({name}); &#34;
                f&#34;the available ones are ({available}). &#34;
                f&#34;{supplemental_msg}&#34;
            )

        filters = []
        keys = []

        for (name, criterion) in query.items():
            if name in key_names:
                # This is handled later...
                continue
            for (operator, value) in criterion.items():
                add_criterion(
                    cond_list=filters,
                    condition_base=conditions.Attr,
                    name=name,
                    operator=operator,
                    value=value
                )

        # Add the dyn-key conditions if needed...
        if dyn_key:
            add_criterion(
                cond_list=keys,
                condition_base=conditions.Key,
                name=structure.dyn_hash_key_name,
                operator=&#39;eq&#39;,
                value=dyn_key.hash_key
            )

            range_key = dyn_key.range_key
            if range_key:
                operator = dyn_key.range_operator or &#39;eq&#39;
                # If we have an &#39;in&#39; operator, we translate that to &#39;eq&#39; for this purpose.
                # We should be called with separate values if there is more than one dyn_key,
                # and so are &#39;simulating&#39; the `is_in` operator aspect.
                if operator == &#39;is_in&#39;:
                    operator = &#39;eq&#39;
                add_criterion(
                    cond_list=keys,
                    condition_base=conditions.Key,
                    name=structure.dyn_range_key_name,
                    operator=operator,
                    value=range_key
                )

        params_to_mod = ((&#39;KeyConditionExpression&#39;, keys), (filter_key, filters))
        for (param_key, exp_list) in params_to_mod:
            for key in exp_list:
                exp = params.get(param_key)
                exp = exp &amp; key if exp is not None else key
                params[param_key] = exp

    def _table_or_batch_writer(self) -&gt; Union[BatchWriter, TableResource]:
        &#34;&#34;&#34;
        Gets either a table or a batch-writer. So you should only call methods that are
        supported by a BatchWriter on this [since it could be one].
        All BatchWriter methods are also supported by a Dynamo TableResource so you&#39;ll be safe
        as long as you limit calls to what BatchWriter supports.
        &#34;&#34;&#34;
        batch_writer = _DynBatchResource.grab().current_writer()
        if batch_writer:
            return batch_writer.batch_writer(api=self.api)

        return self.api.table

    # todo: BaseModel objects are capable of letting us know if something actually changed or not.
    #       At some point take advantage of that.
    #       This would allow us to prevent putting an unchanged item into dynamo [saves cost].
    def _put_item(self, item: &#39;DynModel&#39;, condition: Query = None):
        &#34;&#34;&#34;
        Put item into dynamo-table. WON&#39;T use any current batch-writer if a condition is supplied.
        If a condition is supplied, we always use the table and execute put immediately.

        Object will only be sent if there are any changes in object
        (compared to what was originally retrieved from table).

        If there is a change, entire object with all current attributes will be sent
        (a put fully replaces the item in table, it&#39;s not a PATCH).

        Condition will be sent with put if provided, it will be checked against anything
        that is currently in table before it&#39;s replaced in a transaction-safe way.

        Args:
            item: Item to put into dynamo table; if condition not supplied we check for a current
                batch-writer resource and use that if there is one.
            condition: Conditional query; query is sent to dynamodb, and it will check condition
                against any existing item in a transaction-safe way. If condition checks out
                then the put is done.  Otherwise, it won&#39;t be.
                If it is not, we add a field-error to object to indicate conditional check failed:

                `item.api.response_state.add_field_error(&#39;_conditional_check&#39;, &#39;failed&#39;)`
                or you can use `xyn_model_dynamo.const.CONDITIONAL_CHECK_FAILED_KEY` for
                the field key.
        &#34;&#34;&#34;
        # Check to see if there is anything I actually need to send.
        if not item.api.json(only_include_changes=True, log_output=True, include_removals=True):
            log.info(f&#34;Dynamo - {item} did not have any changes to send, skipping.&#34;)
            return

        structure = self.api.structure
        hash_name = structure.dyn_hash_key_name
        if not getattr(item, hash_name, None):
            raise XRemoteError(f&#34;Item {item} needs a value for hash key ({hash_name}).&#34;)

        range_name = structure.dyn_range_key_name
        if range_name and not getattr(item, range_name, None):
            raise XRemoteError(f&#34;Item {item} needs a value for range key ({range_name}).&#34;)

        # To keep things simple, I am using &#39;put&#39; which replaces entire item,
        # so get all properties of item regardless if they changed or not.
        # todo: Check for primary key and raise a nicer, higher-level exception in that case.
        item.api.response_state.reset()

        params = {
            &#34;Item&#34;: item.api.json()
        }

        resource = self._table_or_batch_writer()
        if condition:

            # Can&#39;t batch-put things with conditions, so we do them one at a time instead.
            resource = self.api.table

            # Add the conditional query to the dynamodb params dict...
            self._add_conditions_from_query(
                query=condition, params=params, filter_key=&#39;ConditionExpression&#39;, consistent_read=False
            )

        # Finally, tell the boto resource to put the item:
        try:
            resource.put_item(**params)
        except dynamodb.meta.client.exceptions.ConditionalCheckFailedException as e:
            # By default, we ignore conditional check failed, because this means we did not want
            # to delete the item on purpose; ie: it&#39;s not an error.
            # conditions are mostly used to prevent race-conditions, hence ignored by default.
            # If someone in the future ends up wanting the exception, we can have an argument
            # or some other way to indicate that we should re-raise the condition check exception.
            # See `self.delete_obj` doc comment (above) for more details.
            log.info(
                f&#34;Didn&#39;t send/put dynamo obj ({item}) due to condition not met ({condition}), &#34;
                f&#34;exception from dynamo ({e}).&#34;
            )
            state = item.api.response_state
            state.had_error = True
            state.errors = [
                &#39;The conditional check failed, item was not deleted.&#39;,
                {&#39;conditional-check-failed-exception&#39;: e}
            ]
            state.add_field_error(field=CONDITIONAL_CHECK_FAILED_KEY, code=&#39;failed&#39;)

    def _get_all_items(self, consistent_read: bool | DefaultType = Default):
        params = {}
        if consistent_read is Default:
            consistent_read = self.consistent_reads

        if consistent_read:
            params[&#39;ConsistentRead&#39;] = True

        return self._paginate_all_items_generator(method=&#39;scan&#39;, params=params)

    def _paginate_all_items_generator(
            self, *,
            method: str,
            params: Dict[str, Any],
            use_table=True,
    ) -&gt; Iterable[M]:
        api = self.api
        model_type = api.model_type
        # Get table name, and also ensures table exists.
        table = api.table
        table_name = table.name
        resource = table if use_table else DynamoDB.grab().db

        while True:
            table_method = getattr(resource, method)
            # Execute Scan/Query on table:
            response = table_method(**params)
            last_key = response.get(&#39;LastEvaluatedKey&#39;, None)

            db_datas = response.get(&#39;Items&#39;)

            if not db_datas:
                responses: Dict[str, List] = response.get(&#34;Responses&#34;)
                if responses:
                    db_datas = responses[table_name]
                else:
                    db_datas = tuple()

            for data in db_datas:
                yield model_type(data)

            if last_key:
                params[&#39;ExclusiveStartKey&#39;] = last_key
                continue

            unprocessed = response.get(&#39;UnprocessedKeys&#39;)
            if not unprocessed:
                return

            # We need to try the fetch again for the remaining items...
            # todo: Boto/AWS recommend an exponential backoff when we retry in this case...
            #   see BatchGetItem / batch_get_item
            params[&#39;RequestItems&#39;] = unprocessed
            continue

    def create_table(self):
        &#34;&#34;&#34;
        This is mainly here to create table when mocking aws for unit tests. If the table
        really does not exist in reality, this also can create it.

        Time To Live Notes:

        We can&#39;t enable TimeToLive during table creation, we have to wait until after it&#39;s
        created. This is a minor issue, since the table will still function correctly,
        the queries will still filter out expired items like normal.  The only difference
        is we could get charged extra for storage we are not using. We need to still filter
        items out of our queries because deletion does not happen immediately [could take up
        to 48 hours].

        At this point, it&#39;s expected that you&#39;ll have to go into the AWS dynamo console
        to setup automatic TimeToLive item deletion for a table if you want this to create it for
        you.

        In reality, serverless framework is expected to setup the real tables for services that
        are running directly in aws; and that&#39;s where you should setup the TTL stuff for real
        tables.
        &#34;&#34;&#34;
        structure = self.api.structure
        hash_key = structure.dyn_hash_key_name
        hash_type = structure.get_field(hash_key).type_hint
        key_schemas = [
            # Partition Key
            {&#39;AttributeName&#39;: hash_key, &#39;KeyType&#39;: &#39;HASH&#39;}
        ]
        attribute_definitions = [
            {
                &#39;AttributeName&#39;: hash_key,
                &#39;AttributeType&#39;: get_dynamo_type_from_python_type(hash_type)
            }
        ]

        # If we have a range-key, add that in.
        range_key = structure.dyn_range_key_name
        if range_key:
            range_type = structure.get_field(range_key).type_hint
            key_schemas.append({
                &#39;AttributeName&#39;: range_key,
                &#39;KeyType&#39;: &#39;RANGE&#39;
            })
            attribute_definitions.append({
                &#39;AttributeName&#39;: range_key,
                &#39;AttributeType&#39;: get_dynamo_type_from_python_type(range_type)
            })

        return DynamoDB.grab().db.create_table(
            TableName=structure.fully_qualified_table_name(),
            KeySchema=key_schemas,
            AttributeDefinitions=attribute_definitions,
            BillingMode=&#39;PAY_PER_REQUEST&#39;,
            Tags=[{&#39;Key&#39;: &#39;DDBTableGroupKey&#39;, &#39;Value&#39;: xcon_settings.service}]
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>xmodel.remote.client.RemoteClient</li>
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="xdynamo.client.DynClient.api"><code class="name">prop <span class="ident">api</span> :Â RemoteApi[M]</code></dt>
<dd>
<div class="desc"><p>Every RemoteModel has a class-based RemoteApi And RestClient instance, this will point to
the class based RemoteApi instance, the same one you would get via
<code>xmodel.remote.model.RemoteModel.api</code>.</p>
<p>When <code>xmodel.remote.api.RemoteApi</code> creates us
(it looks at type-hint on <code>xmodel.remote.api.RemoteApi.client</code>)
it passes it's self to us here.</p>
<p>Only ONE <code>RestClient</code> class is allocated per-<code>xmodel.remote.model.RemoteModel</code>
class/type.
The object instances of the RemoteModel all get a separate
instance of <code>xmodel.remote.api.RemoteApi</code>; but all instances of that model type share
the same <code>RemoteClient</code> instance via <code>xmodel.remote.api.RemoteApi.client</code>.</p>
<p>The typehint on this var is only here to support the IDE, it allows the IDE to know what
<code>xmodel.remote.model.RemoteModel</code> type this client is going to be using.
IDE knows based on how you get the RestClient, when code uses the
<code>xmodel.remote.model.RemoteModel.api</code> attribute; the IDE knows the concrete generic <code>M</code>
type
represents the real <code>xmodel.remote.model.RemoteModel</code> subclass type
(for type completion).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def api(self) -&gt; &#34;RemoteApi[M]&#34;:
    &#34;&#34;&#34;
    Every RemoteModel has a class-based RemoteApi And RestClient instance, this will point to
    the class based RemoteApi instance, the same one you would get via
    `xmodel.remote.model.RemoteModel.api`.

    When `xmodel.remote.api.RemoteApi` creates us
    (it looks at type-hint on `xmodel.remote.api.RemoteApi.client`)
    it passes it&#39;s self to us here.

    Only ONE `RestClient` class is allocated per-`xmodel.remote.model.RemoteModel`
    class/type.
    The object instances of the RemoteModel all get a separate
    instance of `xmodel.remote.api.RemoteApi`; but all instances of that model type share
    the same `RemoteClient` instance via `xmodel.remote.api.RemoteApi.client`.

    The typehint on this var is only here to support the IDE, it allows the IDE to know what
    `xmodel.remote.model.RemoteModel` type this client is going to be using.
    IDE knows based on how you get the RestClient, when code uses the
    `xmodel.remote.model.RemoteModel.api` attribute; the IDE knows the concrete generic `M`
    type
    represents the real `xmodel.remote.model.RemoteModel` subclass type
    (for type completion).

    &#34;&#34;&#34;
    return self._api</code></pre>
</details>
</dd>
<dt id="xdynamo.client.DynClient.consistent_reads"><code class="name">prop <span class="ident">consistent_reads</span> :Â bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def consistent_reads(self) -&gt; bool:
    # Check for injected default, use that if it exists.
    injected_default = dyn_client_options.consistent_read
    if injected_default is not Default:
        return injected_default

    # Otherwise use the model&#39;s default for consistent reads.
    return self.api.structure.dyn_consistent_read or False</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xdynamo.client.DynClient.batch_get"><code class="name flex">
<span>def <span class="ident">batch_get</span></span>(<span>self, keys:Â Iterable[<a title="xdynamo.common_types.DynKey" href="common_types.html#xdynamo.common_types.DynKey">DynKey</a>], *, consistent_read:Â boolÂ |Â xsentinels.default.DefaultTypeÂ =Â Default, **params:Â Dict[str,Â Any]) â>Â Iterable[~M]</span>
</code></dt>
<dd>
<div class="desc"><p>Will fetch keys in the largest batch it can at a time it can from Dynamo;
Dynamo will fetch each page of values in parallel!</p>
<p>We split up the keys into 100 increments at a time automatically right now
For each unique hash key in the set of keys provided, Dynamo will parallel fetch
the keys (if two keys have the same hash but different range key, dynamo will do
them sequentially).</p>
<p>In the future, we may attempt to fetch multiple 100 blocks of keys asynchronously.
As the returned generator/iterable is gone through to increase the speed.
We don't do that yet.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>keys</code></strong> :&ensp;<code>Iterable[DynKey]</code></dt>
<dd>
<p>Keys to fetch.
Can be of any size, a generator will be returned to minimize memory use.</p>
<div class="admonition tip">
<p class="admonition-title">Tip:&ensp;If you pass in a <code>set</code>, we will be slightly more efficient.</p>
<p>We need to ensure the results are uniquified, if you pass a set we can skip
doing it.</p>
</div>
</dd>
<dt><strong><code>consistent_read</code></strong></dt>
<dd>
<p>Defaults to Model.api.structure.dyn_consistent_read,
which can be set via class arguments when DynModel subclass is defined.</p>
<p>You can use this to override the model default. True means we use consistent
reads, otherwise false.</p>
</dd>
<dt><strong><code>**params</code></strong></dt>
<dd>An optional set of extra parameters to include in request to Dynamo,
if so desired.</dd>
</dl>
<p>Returns: An Iterable/Generator that will efficiently paginate though the results for you.</p></div>
</dd>
<dt id="xdynamo.client.DynClient.create_table"><code class="name flex">
<span>def <span class="ident">create_table</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This is mainly here to create table when mocking aws for unit tests. If the table
really does not exist in reality, this also can create it.</p>
<p>Time To Live Notes:</p>
<p>We can't enable TimeToLive during table creation, we have to wait until after it's
created. This is a minor issue, since the table will still function correctly,
the queries will still filter out expired items like normal.
The only difference
is we could get charged extra for storage we are not using. We need to still filter
items out of our queries because deletion does not happen immediately [could take up
to 48 hours].</p>
<p>At this point, it's expected that you'll have to go into the AWS dynamo console
to setup automatic TimeToLive item deletion for a table if you want this to create it for
you.</p>
<p>In reality, serverless framework is expected to setup the real tables for services that
are running directly in aws; and that's where you should setup the TTL stuff for real
tables.</p></div>
</dd>
<dt id="xdynamo.client.DynClient.delete_obj"><code class="name flex">
<span>def <span class="ident">delete_obj</span></span>(<span>self, obj:Â Union[~M,Â <a title="xdynamo.common_types.DynKey" href="common_types.html#xdynamo.common_types.DynKey">DynKey</a>], *, condition:Â Dict[str,Â Union[str,Â int,Â datetime.date,Â xurls.url._FormattedQueryValue,Â ForwardRef(None),Â uuid.UUID,Â Iterable[strÂ |Â intÂ |Â uuid.UUIDÂ |Â datetime.dateÂ |Â xurls.url._FormattedQueryValue]]]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Attempts to delete passed in object from dynamodb table.</p>
<p>If you pass in a condition, it will be evaluated on the dynamodb-service side and the
deletes will only happen if the condition is met.
This can help prevent race conditions if used correctly.</p>
<p>If there is a batch-writer currently in use, we will try to use that to batch the deletes.</p>
<p>Keep in mind that if you pass in a <code>condition</code>, we can't use the batch write.
We will instead send of a single-item delete request with the condition attached
(bypassing any current batch-writer that may be in use).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong></dt>
<dd>Object to delete, it MUST have values for it's primary key(s)
(no other values are required, the primary-key values are the only ones used).</dd>
<dt><strong><code>condition</code></strong></dt>
<dd>
<p>Optional, if passed in we will send this as a <code>ConditionExpression</code>
to dynamo.
You can pass in a Query, ie: the same structure that is used
for <code>self.query()</code> and <code>self.scan()</code>.</p>
<p>We will take the Query correctly format it for you into the <code>ConditionExpression</code>.</p>
<p>If the condition is met, the item will be deleted.</p>
<p>If the condition is NOT met, we will handle it for you by catch the exception,
logging about it, setting error on response_state of object, and then returning.
Conditions are generally used to help prevent race-conditions,
ie: to prevent a deleted on purpose.</p>
<p>Most of the time the intent is to ignore what the result is, it was either
deleted or not;
ie: it will eventually be handled in some way it if it was not deleted.</p>
<p>If you want to know when a conditional delete fails, you can look at
deleted objects <code>obj.api.response_state</code>.</p>
<p>It's <code>had_error</code> will be <code>True</code>, there will be some info in <code>errors</code>,
but also a field error with name <code>_conditional_check</code> and code <code>failed</code>
you can easily check for via:</p>
<p><code>....response_state.has_field_error('_conditional_check', 'failed')</code></p>
<p>or you can use <code>xyn_model_dynamo.const.CONDITIONAL_CHECK_FAILED_KEY</code> for
the field key.</p>
</dd>
</dl></div>
</dd>
<dt id="xdynamo.client.DynClient.delete_objs"><code class="name flex">
<span>def <span class="ident">delete_objs</span></span>(<span>self, objs:Â Sequence[Union[~M,Â <a title="xdynamo.common_types.DynKey" href="common_types.html#xdynamo.common_types.DynKey">DynKey</a>]], condition:Â Dict[str,Â Union[str,Â int,Â datetime.date,Â xurls.url._FormattedQueryValue,Â ForwardRef(None),Â uuid.UUID,Â Iterable[strÂ |Â intÂ |Â uuid.UUIDÂ |Â datetime.dateÂ |Â xurls.url._FormattedQueryValue]]]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses a batch-writer to put the items. Much more efficient than doing it one at a time.</p>
<p>If you pass in a <code>condition</code>, the batch-writer can't be used and normal single-deletes
will automatically be used instead.</p>
<p>If you only give me one item, directly calls <code>delete_obj</code> without a batch-writer.</p></div>
</dd>
<dt id="xdynamo.client.DynClient.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, query:Â Dict[str,Â Union[str,Â int,Â datetime.date,Â xurls.url._FormattedQueryValue,Â ForwardRef(None),Â uuid.UUID,Â Iterable[strÂ |Â intÂ |Â uuid.UUIDÂ |Â datetime.dateÂ |Â xurls.url._FormattedQueryValue]]]Â =Â None, *, top:Â intÂ =Â None, fields:Â Sequence[str]Â =Â Default, allow_scan:Â boolÂ =Â False, consistent_read:Â boolÂ |Â xsentinels.default.DefaultTypeÂ =Â Default, **dynamo_params) â>Â Iterable[~M]</span>
</code></dt>
<dd>
<div class="desc"><p>This is the standard/abstract interface method that all RestClient's support.</p>
<p>The idea behind this method is to figure out how to route this query in the most
efficient manner we can do it in. If you want to guarantee a specific type of query
you can use <code><a title="xdynamo.client.DynClient.query" href="#xdynamo.client.DynClient.query">DynClient.query()</a></code>, etc.</p>
<p>Generally, this is the best, generally method to use since it can adapt your request
to the most efficient way to query Dynamo. The <code>DynApi</code> will use this method generally
when it's asked to get something (for example, when using <code>DynApi.get_via_id</code>).</p>
<p>For more info on how you can query, see:</p>
<ul>
<li><a href="#advanced-queries">Advanced Queries</a><ul>
<li><a href="#examples_1">Examples</a></li>
</ul>
</li>
</ul>
<p>Here is the general process this method goes though to determine how to query dynamo
for a given query:</p>
<ol>
<li>If provided query is empty.<ul>
<li>Will paginate though all items in table efficiently; multiple items
will be returned per-request in parallel.
You'll get back a generator that gives you an object at time, but behind
the scenes we are getting a page at a time from dynamo.</li>
</ul>
</li>
<li>We will try to batch it en-mass in parallel if we can.
We can do this if one of the following is true:<ul>
<li>Query only contains 'id' key; this is because an 'id' should have full primary key;
meaning it will contain both hash and range key (if needed).
You can provide a list of strings or <code>DynKey</code> objects.<ul>
<li>See <code>DynModel.id</code> for more details on how to use <code>str</code> with an 'id'.</li>
<li>See <code>DynKey</code> for more details on what a composite primary-key as a <code>str</code> is
like.</li>
</ul>
</li>
<li>Table only has a hash-key (no range/sort key) and you provide nothing but
hash-keys (ie: no other attributes in query)</li>
</ul>
</li>
<li>Next, we see if we can use a Dynamo query via <code><a title="xdynamo.client.DynClient.query" href="#xdynamo.client.DynClient.query">DynClient.query()</a></code>.<ul>
<li>This will use multiple queries if/as needed, but while minimizing the number of
queries that are needed. Just depends on the query that is provided.
More then one query is needed if there is more then one hash-key in the query,
and there are other attributes you are filtering on
(and so #2 above, batch-get, can't be used)
Doing multiple queries is still far-faster then doing a scan.
We return objects via the generator and only execute the second (or more)
queries</li>
<li>In the future, this will automatically querying a Secondary Index if one is
available.
(Not Implemented Yet, we will add this when needed)</li>
</ul>
</li>
<li>Next, fallback to using a Global Index if one is available.<ul>
<li>(Not Implemented Yet, we will do it when we need it)</li>
</ul>
</li>
<li>If that's not possible, in the future we fallback to scan operation.<ul>
<li>(Not Implemented Yet; This isn't implemented currently and will raise NotImplemented.
Scan operations can be very slow and so it's not something we really want to do
normally&hellip; I did implement this if getting everything, but with filters/attributes
to query on I decided to wait until we need it before implementing this currently).</li>
</ul>
</li>
</ol>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>Implement querying via Secondary/Global indexes; Scanning with query values.
see above for details.</p>
</div>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>query</code></strong></dt>
<dd>
<p>Dict keys are the attribute/key names and values are what
to filter on for that name.
Operators after double <code>__</code> work just like you
would expect for our xyngular API's&hellip; here is an example:</p>
<p><code>python
{ "some_attr_name__gte": 2 }</code></p>
<p>In this case, we look for <code>some_attr_name</code> greater than or equal to integer <code>2</code>.</p>
<p>You MUST provide at least one value for the hash key of the table for right now.
In the future, we will support doing a table-scan to support queries without
a hash-key. But for right now it's required.</p>
<p>For more information with examples see <a href="#advanced-queries">Advanced Queries</a>.</p>
</dd>
<dt><strong><code>top</code></strong></dt>
<dd>This is supposed to only return this mean records; currently not implemented.</dd>
<dt><strong><code>fields</code></strong></dt>
<dd>This is supposed to only retrieve provided field names in returned objects;
currently not implemented.</dd>
<dt><strong><code>allow_scan</code></strong></dt>
<dd>
<p>Defaults to False, which means this will raise an exception if a scan
is required to execute your get.
Set to True to allow a scan if needed
(it will still do a query, batch-get, etc; if it can, it only does a scan
if there is no other choice).</p>
<p>If the query is blank or None will still do a scan regardless of what you pass
(to return all items in the table).</p>
</dd>
<dt><strong><code>consistent_read</code></strong></dt>
<dd>
<p>Defaults to Model.api.structure.dyn_consistent_read,
which can be set via class arguments when DynModel subclass is defined.</p>
<p>You can use this to override the model default. True means we use consistent
reads, otherwise false.</p>
</dd>
<dt><strong><code>**dynamo_params</code></strong></dt>
<dd>Extra parameters to include on the Dynamo request(s) that are
generated. This is 100% optional.</dd>
</dl>
<p>Returns:</p></div>
</dd>
<dt id="xdynamo.client.DynClient.query"><code class="name flex">
<span>def <span class="ident">query</span></span>(<span>self, query:Â Dict[str,Â Union[str,Â int,Â datetime.date,Â xurls.url._FormattedQueryValue,Â ForwardRef(None),Â uuid.UUID,Â Iterable[strÂ |Â intÂ |Â uuid.UUIDÂ |Â datetime.dateÂ |Â xurls.url._FormattedQueryValue]]]Â =Â None, *, consistent_read:Â boolÂ |Â xsentinels.default.DefaultTypeÂ =Â Default, **dynamo_params:Â Dict[str,Â Any]) â>Â Iterable[~M]</span>
</code></dt>
<dd>
<div class="desc"><p>Forces <code><a title="xdynamo.client.DynClient" href="#xdynamo.client.DynClient">DynClient</a></code> to use a query. If you want a way for client to automatically
figure out the best way to execute your query, use one of these instead:</p>
<ul>
<li><code>DynApi.get</code></li>
<li><code><a title="xdynamo.client.DynClient.get" href="#xdynamo.client.DynClient.get">DynClient.get()</a></code></li>
</ul>
<p>For more info see:</p>
<ul>
<li><a href="#advanced-queries">Advanced Queries</a><ul>
<li><a href="#examples_1">Examples</a></li>
</ul>
</li>
</ul>
<p>For a quick summary on how to provide query,
see 'query' argument doc (just a few lines down).
But I would highly recommend looking at <a href="#advanced-queries">Advanced Queries</a> for
more details with examples!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>api</code></strong> :&ensp;<code>DynApi</code></dt>
<dd>BaseApi object to use, this is how we know the table name, model class,
etc.</dd>
<dt><strong><code>query</code></strong> :&ensp;<code>Query</code></dt>
<dd>
<p>You can give a simple dict here, modeled after how the standard rest-api
query dict's work. Dict keys are the attribute/key names and values are what
to filter on for that name.
Operators after double <code>__</code> work just like you
would expect for our xyngular API's&hellip; here is an example:</p>
<p><code>python
{ "some_attr_name__gte": 2 }</code></p>
<p>In this case, we look for <code>some_attr_name</code> greater than or equal to integer <code>2</code>.</p>
<p>You MUST provide at least one value for the hash key of the table when using
<code>query</code> or boto3/dynamo will raise an exception.</p>
<p>This is an easy way to fill out <code>KeyConditionExpression</code> and/or <code>FilterExpression</code>.
This method can figure out which attribute goes with which one and construct
both expressions as needed.</p>
<p>For more information with examples see <a href="#advanced-queries">Advanced Queries</a>.</p>
</dd>
<dt><strong><code>consistent_read</code></strong></dt>
<dd>
<p>Defaults to Model.api.structure.dyn_consistent_read,
which can be set via class arguments when DynModel subclass is defined.</p>
<p>You can use this to override the model default. True means we use consistent
reads, otherwise false.</p>
</dd>
<dt><strong><code>**params</code></strong> :&ensp;<code>DynParams</code></dt>
<dd>
<p>You can provide other standard boto3 query parameters here as you
need. If you provide both dynamo_params and query, the ones in query will overwrite
ones in dynamo_params if there is a conflict;</p>
<p>The <code>query</code> param could use either a <code>KeyConditionExpression</code> or <code>FilterExpression</code>
depending on what attributes are in the query dict.</p>
</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>M</code></dt>
<dd>(DynModel subclass instances) - The next object we got from dynamo.
This method returns a generator that will eventually go through all the results
from dynamo in a memory-efficient manner.</dd>
</dl></div>
</dd>
<dt id="xdynamo.client.DynClient.scan"><code class="name flex">
<span>def <span class="ident">scan</span></span>(<span>self, query:Â Dict[str,Â Union[str,Â int,Â datetime.date,Â xurls.url._FormattedQueryValue,Â ForwardRef(None),Â uuid.UUID,Â Iterable[strÂ |Â intÂ |Â uuid.UUIDÂ |Â datetime.dateÂ |Â xurls.url._FormattedQueryValue]]]Â =Â None, *, consistent_read:Â boolÂ |Â xsentinels.default.DefaultTypeÂ =Â Default, **dynamo_params:Â Dict[str,Â Any]) â>Â Iterable[~M]</span>
</code></dt>
<dd>
<div class="desc"><p>Scans entire table (vs doing a <code><a title="xdynamo.client.DynClient.query" href="#xdynamo.client.DynClient.query">DynClient.query()</a></code>, which is much more efficient).
Looks at every item in the table, evaluating <code>query</code> to filter which ones to return.
The scanning/filtering happens on the server-side.</p>
<p>If provided query is empty, will return all items in the table.</p></div>
</dd>
<dt id="xdynamo.client.DynClient.send_objs"><code class="name flex">
<span>def <span class="ident">send_objs</span></span>(<span>self, objs:Â Sequence[~M], *, condition:Â Dict[str,Â Union[str,Â int,Â datetime.date,Â xurls.url._FormattedQueryValue,Â ForwardRef(None),Â uuid.UUID,Â Iterable[strÂ |Â intÂ |Â uuid.UUIDÂ |Â datetime.dateÂ |Â xurls.url._FormattedQueryValue]]]Â =Â None, url:Â xurls.url.UrlÂ |Â strÂ |Â NoneÂ =Â None, send_limit:Â intÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Used to send any number of objects to Dynamo in as efficient a manner as possible.</p>
<p>If possible, uses a batch-writer to put the items.
It's WAY more efficient than doing it one at a time.</p>
<p>If a condition is supplied, won't use a batch-writer as only one item can be put
at a time with a condition.</p>
<p>In the future at some point, will support transactions and at that point could put
more items per-request at a time with condition(s).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>objs</code></strong></dt>
<dd>Objects to send to dynamo.</dd>
<dt><strong><code>url</code></strong></dt>
<dd>Not used in Dynamo, ignore</dd>
<dt><strong><code>send_limit</code></strong></dt>
<dd>Currently unused, we try to push as much as possible.</dd>
<dt><strong><code>condition</code></strong></dt>
<dd>
<p>Optional, if passed in we will send this as a <code>ConditionExpression</code>
to dynamo.
You can pass in a Query, ie: the same structure that is used
for <code>self.query()</code> and <code>self.scan()</code>.</p>
<p>We will take the Query correctly format it for you into the <code>ConditionExpression</code>.</p>
<p>If the condition is met, the item will be put into table.</p>
<p>If the condition is NOT met, we will handle it for you by catch the exception,
logging about it, setting error on response_state of object, and then returning.
Conditions are generally used to help prevent race-conditions,
ie: to prevent a put on purpose; so we don't raise an exception.</p>
<p>Most of the time the intent is to ignore what the result is, it was either
put into table or not;
ie: it will eventually be handled in some way it if it was not put into table.</p>
<p>If you want to know when a conditional delete fails, you can look at
deleted objects <code>obj.api.response_state</code>.</p>
<p>It's <code>had_error</code> will be <code>True</code>, there will be some info in <code>errors</code>,
but also a field error with name <code>_conditional_check</code> and code <code>failed</code>
you can easily check for via:</p>
<p><code>....response_state.has_field_error('_conditional_check', 'failed')</code></p>
<p>or you can use <code>xdynamo.const.CONDITIONAL_CHECK_FAILED_KEY</code> for
the field key.</p>
</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="xdynamo.client.DynClientOptions"><code class="flex name class">
<span>class <span class="ident">DynClientOptions</span></span>
<span>(</span><span>*, consistent_read:Â boolÂ |Â xsentinels.default.DefaultTypeÂ =Â Default)</span>
</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code>xinject.context.XContext</code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code>xinject.context.XContext</code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code>xinject.context.XContext</code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code>xinject.pytest_plugin.xinject_test_context</code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DynClientOptions(Dependency):
    def __init__(self, *, consistent_read: bool | DefaultType = Default):
        self.consistent_read = consistent_read

    consistent_read: bool | DefaultType = Default
    &#34;&#34;&#34; Way to change what the default consistent read value should be,
        If set it will be used over the default value for the model
        (but won&#39;t override True/False passed directly to client as method paramter to get/scan/etc.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>xinject.dependency.Dependency</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xdynamo.client.DynClientOptions.consistent_read"><code class="name">var <span class="ident">consistent_read</span> :Â boolÂ |Â xsentinels.default.DefaultType</code></dt>
<dd>
<div class="desc"><p>Way to change what the default consistent read value should be,
If set it will be used over the default value for the model
(but won't override True/False passed directly to client as method paramter to get/scan/etc.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="xdynamo" href="index.html">xdynamo</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="xdynamo.client.dyn_client_options" href="#xdynamo.client.dyn_client_options">dyn_client_options</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="xdynamo.client.DynClient" href="#xdynamo.client.DynClient">DynClient</a></code></h4>
<ul class="two-column">
<li><code><a title="xdynamo.client.DynClient.api" href="#xdynamo.client.DynClient.api">api</a></code></li>
<li><code><a title="xdynamo.client.DynClient.batch_get" href="#xdynamo.client.DynClient.batch_get">batch_get</a></code></li>
<li><code><a title="xdynamo.client.DynClient.consistent_reads" href="#xdynamo.client.DynClient.consistent_reads">consistent_reads</a></code></li>
<li><code><a title="xdynamo.client.DynClient.create_table" href="#xdynamo.client.DynClient.create_table">create_table</a></code></li>
<li><code><a title="xdynamo.client.DynClient.delete_obj" href="#xdynamo.client.DynClient.delete_obj">delete_obj</a></code></li>
<li><code><a title="xdynamo.client.DynClient.delete_objs" href="#xdynamo.client.DynClient.delete_objs">delete_objs</a></code></li>
<li><code><a title="xdynamo.client.DynClient.get" href="#xdynamo.client.DynClient.get">get</a></code></li>
<li><code><a title="xdynamo.client.DynClient.query" href="#xdynamo.client.DynClient.query">query</a></code></li>
<li><code><a title="xdynamo.client.DynClient.scan" href="#xdynamo.client.DynClient.scan">scan</a></code></li>
<li><code><a title="xdynamo.client.DynClient.send_objs" href="#xdynamo.client.DynClient.send_objs">send_objs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="xdynamo.client.DynClientOptions" href="#xdynamo.client.DynClientOptions">DynClientOptions</a></code></h4>
<ul class="">
<li><code><a title="xdynamo.client.DynClientOptions.consistent_read" href="#xdynamo.client.DynClientOptions.consistent_read">consistent_read</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
