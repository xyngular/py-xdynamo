<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>xdynamo.api API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>xdynamo.api</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import TypeVar, Optional, Any, Union, List, Dict, Iterable
from boto3.dynamodb.table import TableResource

from .db import DynamoDB

from xmodel.common.types import FieldNames
from xmodel.remote import XRemoteError
from xmodel.remote.api import RemoteApi
from xdynamo.client import DynClient
from xdynamo.common_types import DynKey
from xdynamo.fields import DynField
from xdynamo.structure import DynStructure
from xsentinels.default import Default
from xurls.url import Query
from xloop import xloop

M = TypeVar(&#39;M&#39;)


class DynApi(RemoteApi[M]):
    &#34;&#34;&#34;
    Put things here that are only relevant for all DynModel&#39;s.

    The main change vs the base BaseApi class is filtering out of the JSON invalid blank values.

    Right now this model class is only used to transform json from/to Dynamo via
    the `json` and `update_from_json()` methods. See `xmodel.base.api.BaseApi` for more
    details.
    &#34;&#34;&#34;
    client: DynClient[M]
    structure: DynStructure[DynField]

    def get_key(self, hash_key: Any, range_key: Optional[Any] = None) -&gt; DynKey:
        &#34;&#34;&#34;
        Easy way to generate a basic `DynKey` with hash_key, and range_key
        (if model has range key).

        If you don&#39;t provide a range-key and the model needs a range-key,
        will raise an `xmodel.remote.errors.XRemoteError`.
        &#34;&#34;&#34;
        return DynKey(api=self, hash_key=hash_key, range_key=range_key)

    def get_via_id(
            self,
            id: Union[
                Union[int, str, DynKey],
                List[Union[int, str, DynKey]],
                Dict[str, Union[str, int]],
                List[Dict[str, Union[str, int]]],
            ],
            fields: FieldNames = Default,
            id_field: str = None,
            aux_query: Query = None
    ) -&gt; Union[Iterable[M], M, None]:
        &#34;&#34;&#34;
        Overridden in DynApi to convert any provided `DynKey` into string-based `id` and
        passing them to super and returning the result.

        See `xmodel.remote.api.RemoteApi.get_via_id` for more details on how this method works.

        Args:
            id: In addition to `str` and `int` values, you can also used `DynKey`(s) if you wish.
            fields: See `xmodel.remote.api.RemoteApi.get_via_id`
            id_field: See `xmodel.remote.api.RemoteApi.get_via_id`
            aux_query: See `xmodel.remote.api.RemoteApi.get_via_id`

        Returns:
            See `xmodel.remote.api.RemoteApi.get_via_id`
        &#34;&#34;&#34;
        if id is None:
            return None

        is_list = isinstance(id, list)
        if is_list:
            id: Union[DynKey, int, str]
            new_id = [v.id if type(v) is DynKey else v for v in xloop(id)]
        else:
            new_id = id.id if type(id) is DynKey else id

        return super().get_via_id(new_id, fields=fields, id_field=id_field, aux_query=aux_query)

    @property
    def table(self) -&gt; TableResource:
        &#34;&#34;&#34; Returns the boto3 table resource to use for our related DynModel.
            Don&#39;t cache or hang onto this, it&#39;s already properly cached for you via the current
            Context and so will work in every situation [unit-tests, config-changes, etc]...
        &#34;&#34;&#34;

        if not self.structure.dyn_hash_key_name:
            raise XRemoteError(
                f&#34;While constructing {self.structure.model_cls}, found no hash-key field. &#34;
                f&#34;You must have at least one hash-key field.&#34;
            )

        # Look it up each time in case config/service/env/context changes enough
        # for it to be different. DynamoDB will cache the table by name and so it&#39;s
        # very fast on subsequent lookups.
        table_name = self.structure.fully_qualified_table_name()

        # noinspection PyTypeChecker
        return DynamoDB.grab().table(name=table_name, table_creator=self._create_table)

    def _create_table(self, dynamo: DynamoDB) -&gt; TableResource:
        return self.client.create_table()

    def json(self, **kwargs) -&gt; Optional[Dict[str, Any]]:
        &#34;&#34;&#34;
        See `xmodel.base.api.BaseApi.json`() for docs.

        This filters/modifies the json to make it compliant with Dynamo.
        Example: Dynamo does not like blank strings as attribute values.

        Right now this simply deletes the values out of the json dict if they are blank.
        If we start doing patch-like updates [and not full puts] with dynamo, we could
        easily adapt to detect when we are blanking a value so we can tell dynamo to
        remove the attribute in the item during the patch-like update.

        For now we only use full &#39;puts&#39; to update dynamo items regardless of what actually
        changed [we can detect changes, I would like to support this sort of thing this when
        we add support for Dynamo Transactions, ie: grouping multiple creates/updates into a
        single request. With a transaction, it&#39;s possible to only update specific attributes in a
        dynamo row, while leaving any other attributes alone/in-tact.
        (https://app.shortcut.com/xyngular/story/13989) [consolidate dynamo code]
        &#34;&#34;&#34;
        # This dict is a copy and can be mutated without a problem.
        json = super().json(**kwargs)
        if not json:
            return json

        for k in list(json.keys()):
            v = json[k]
            if isinstance(v, str) and not v:
                del json[k]

        return json</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="xdynamo.api.DynApi"><code class="flex name class">
<span>class <span class="ident">DynApi</span></span>
<span>(</span><span>*, api: BaseApi[M] = None, model: xmodel.base.model.BaseModel = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Put things here that are only relevant for all DynModel's.</p>
<p>The main change vs the base BaseApi class is filtering out of the JSON invalid blank values.</p>
<p>Right now this model class is only used to transform json from/to Dynamo via
the <code>json</code> and <code>update_from_json()</code> methods. See <code>xmodel.base.api.BaseApi</code> for more
details.</p>
<div class="admonition warning">
<p class="admonition-title">Warning:&ensp;You can probably skip the rest (below)</p>
<p>Most of the time you don't create <code>BaseApi</code> objects your self, and so for most people
you can skip the following unless you want to know more about internal details.</p>
</div>
<h1 id="init-method-specifics">Init Method Specifics</h1>
<p>Normally you would not create an <code>BaseApi</code> object directly your self.
<code>xmodel.base.model.BaseModel</code>'s know how to do this automatically.
It happens in <code>xmodel.base.model.BaseModel.__init_subclass__</code>.</p>
<p>Details about how the arguments you can pass are below.</p>
<h2 id="basemodel-class-construction">BaseModel Class Construction:</h2>
<p>If you provide an <code>api</code> arg without a <code>model</code> arg; we will copy the <code>BaseApi.structure</code>
into new object, resetting the error status, and internal <code>BaseApi._state</code> to None.
This <code>api</code> object is supposed to be the parent BaseModel's class api object.</p>
<p>If both <code>api</code> arg + <code>model</code> arg are <code>None</code>, the BaseModel is the root/generic BaseModel
(ie: it has no parent BaseModel).</p>
<p>This is what is done by BaseModel classes while the class is lazily loading and
creating/configuring the BaseModel class and it's associated <code>BaseApi</code> object
(accessible via <code>xmodel.base.model.BaseModel.api</code>)</p>
<h2 id="basemodel-instance-creation">BaseModel Instance Creation:</h2>
<p>If you also pass in a <code>model</code> arg; this get you a special copy of the api you passed in
for use just with that BaseModel instance. The model <code>BaseApi._state</code> will be allocated
internally in the init'd BaseApi object. This is how a <code>xmodel.base.model.BaseModel</code>
instance get's it's own associated <code>BaseApi</code> object
(that's a different instance vs the one set on BaseModel class when the BaseModel class
was originally constructed).</p>
<p>All params are optional.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>api</code></strong></dt>
<dd>
<p>The "parent" BaseApi obj to copy the basic structure from as a starting point,
etc.
The superclasses BaseApi class is passed via this arg.
This is only used when allocating a new <code>BaseApi</code> object for a new
<code>xmodel.base.model.BaseModel</code> class (not an instance, a model class/type).
This BaseApi object is used for the class-level BaseModel api object;
ie: via "ModelClass.api"</p>
<p>See above "BaseModel Class Construction" for more details.</p>
</dd>
<dt><strong><code>model</code></strong></dt>
<dd>
<p>BaseModel to associate new BaseApi obj with.
This is only used to create a new BaseApi object for a
<code>xmodel.base.model.BaseModel</code>
instance for an already-existing type. ie: for BaseModel object instances.</p>
<p>See above "BaseModel Instance Creation" for more details.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DynApi(RemoteApi[M]):
    &#34;&#34;&#34;
    Put things here that are only relevant for all DynModel&#39;s.

    The main change vs the base BaseApi class is filtering out of the JSON invalid blank values.

    Right now this model class is only used to transform json from/to Dynamo via
    the `json` and `update_from_json()` methods. See `xmodel.base.api.BaseApi` for more
    details.
    &#34;&#34;&#34;
    client: DynClient[M]
    structure: DynStructure[DynField]

    def get_key(self, hash_key: Any, range_key: Optional[Any] = None) -&gt; DynKey:
        &#34;&#34;&#34;
        Easy way to generate a basic `DynKey` with hash_key, and range_key
        (if model has range key).

        If you don&#39;t provide a range-key and the model needs a range-key,
        will raise an `xmodel.remote.errors.XRemoteError`.
        &#34;&#34;&#34;
        return DynKey(api=self, hash_key=hash_key, range_key=range_key)

    def get_via_id(
            self,
            id: Union[
                Union[int, str, DynKey],
                List[Union[int, str, DynKey]],
                Dict[str, Union[str, int]],
                List[Dict[str, Union[str, int]]],
            ],
            fields: FieldNames = Default,
            id_field: str = None,
            aux_query: Query = None
    ) -&gt; Union[Iterable[M], M, None]:
        &#34;&#34;&#34;
        Overridden in DynApi to convert any provided `DynKey` into string-based `id` and
        passing them to super and returning the result.

        See `xmodel.remote.api.RemoteApi.get_via_id` for more details on how this method works.

        Args:
            id: In addition to `str` and `int` values, you can also used `DynKey`(s) if you wish.
            fields: See `xmodel.remote.api.RemoteApi.get_via_id`
            id_field: See `xmodel.remote.api.RemoteApi.get_via_id`
            aux_query: See `xmodel.remote.api.RemoteApi.get_via_id`

        Returns:
            See `xmodel.remote.api.RemoteApi.get_via_id`
        &#34;&#34;&#34;
        if id is None:
            return None

        is_list = isinstance(id, list)
        if is_list:
            id: Union[DynKey, int, str]
            new_id = [v.id if type(v) is DynKey else v for v in xloop(id)]
        else:
            new_id = id.id if type(id) is DynKey else id

        return super().get_via_id(new_id, fields=fields, id_field=id_field, aux_query=aux_query)

    @property
    def table(self) -&gt; TableResource:
        &#34;&#34;&#34; Returns the boto3 table resource to use for our related DynModel.
            Don&#39;t cache or hang onto this, it&#39;s already properly cached for you via the current
            Context and so will work in every situation [unit-tests, config-changes, etc]...
        &#34;&#34;&#34;

        if not self.structure.dyn_hash_key_name:
            raise XRemoteError(
                f&#34;While constructing {self.structure.model_cls}, found no hash-key field. &#34;
                f&#34;You must have at least one hash-key field.&#34;
            )

        # Look it up each time in case config/service/env/context changes enough
        # for it to be different. DynamoDB will cache the table by name and so it&#39;s
        # very fast on subsequent lookups.
        table_name = self.structure.fully_qualified_table_name()

        # noinspection PyTypeChecker
        return DynamoDB.grab().table(name=table_name, table_creator=self._create_table)

    def _create_table(self, dynamo: DynamoDB) -&gt; TableResource:
        return self.client.create_table()

    def json(self, **kwargs) -&gt; Optional[Dict[str, Any]]:
        &#34;&#34;&#34;
        See `xmodel.base.api.BaseApi.json`() for docs.

        This filters/modifies the json to make it compliant with Dynamo.
        Example: Dynamo does not like blank strings as attribute values.

        Right now this simply deletes the values out of the json dict if they are blank.
        If we start doing patch-like updates [and not full puts] with dynamo, we could
        easily adapt to detect when we are blanking a value so we can tell dynamo to
        remove the attribute in the item during the patch-like update.

        For now we only use full &#39;puts&#39; to update dynamo items regardless of what actually
        changed [we can detect changes, I would like to support this sort of thing this when
        we add support for Dynamo Transactions, ie: grouping multiple creates/updates into a
        single request. With a transaction, it&#39;s possible to only update specific attributes in a
        dynamo row, while leaving any other attributes alone/in-tact.
        (https://app.shortcut.com/xyngular/story/13989) [consolidate dynamo code]
        &#34;&#34;&#34;
        # This dict is a copy and can be mutated without a problem.
        json = super().json(**kwargs)
        if not json:
            return json

        for k in list(json.keys()):
            v = json[k]
            if isinstance(v, str) and not v:
                del json[k]

        return json</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>xmodel.remote.api.RemoteApi</li>
<li>xmodel.base.api.BaseApi</li>
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="xdynamo.api.DynApi.client"><code class="name">var <span class="ident">client</span> : <a title="xdynamo.client.DynClient" href="client.html#xdynamo.client.DynClient">DynClient</a>[~M]</code></dt>
<dd>
<div class="desc"><p>Returns an appropriate concrete <code>xmodel.remote.client.RemoteClient</code> subclass.
We figure out the proper client object to use based on the type-hint for "client"
property on the sub-class.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from typing import TypeVar
&gt;&gt;&gt; from xmodel import RestApi, RestClient
&gt;&gt;&gt; M = TypeVar(&quot;M&quot;)  # &lt;-- This allows IDE to do better code completion.
&gt;&gt;&gt;
&gt;&gt;&gt; class MyClient(RestClient[M]):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; class MyApi(RestApi[M])
&gt;&gt;&gt;     client: MyClient[M]  # &lt;-- Type hint on 'client' property.
</code></pre>
<p>This is enough for <code>xmodel.base.BaseModel</code> subclasses that have this set as their
api type-hint:</p>
<pre><code>&gt;&gt;&gt; from xmodel.remote.model import RemoteModel
&gt;&gt;&gt;
&gt;&gt;&gt; class MyModel(RemoteModel):
&gt;&gt;&gt;     api: MyApi
</code></pre>
<p>When you get MyModel's api like below, it will return a MyApi instance,
MyApi will in turn return a MyClient:</p>
<pre><code>&gt;&gt;&gt; print(MyModel.api)
MyApi(...)
&gt;&gt;&gt; print(MyModel.api.client)
MyClient(...)
</code></pre>
<p>For a more concreate use/example, see <code>xmodel_rest.RestModel</code>;
it's a RemoteModel subclass that implments a RestClient that can be used with it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def _client(self):
    &#34;&#34;&#34; Returns an appropriate concrete `xmodel.remote.client.RemoteClient` subclass.
        We figure out the proper client object to use based on the type-hint for &#34;client&#34;
        property on the sub-class.

        Example:

            &gt;&gt;&gt; from typing import TypeVar
            &gt;&gt;&gt; from xmodel import RestApi, RestClient
            &gt;&gt;&gt; M = TypeVar(&#34;M&#34;)  # &lt;-- This allows IDE to do better code completion.
            &gt;&gt;&gt;
            &gt;&gt;&gt; class MyClient(RestClient[M]):
            &gt;&gt;&gt;     pass
            &gt;&gt;&gt;
            &gt;&gt;&gt; class MyApi(RestApi[M])
            &gt;&gt;&gt;     client: MyClient[M]  # &lt;-- Type hint on &#39;client&#39; property.

        This is enough for `xmodel.base.BaseModel` subclasses that have this set as their
        api type-hint:

            &gt;&gt;&gt; from xmodel.remote.model import RemoteModel
            &gt;&gt;&gt;
            &gt;&gt;&gt; class MyModel(RemoteModel):
            &gt;&gt;&gt;     api: MyApi

        When you get MyModel&#39;s api like below, it will return a MyApi instance,
        MyApi will in turn return a MyClient:

            &gt;&gt;&gt; print(MyModel.api)
            MyApi(...)
            &gt;&gt;&gt; print(MyModel.api.client)
            MyClient(...)

        For a more concreate use/example, see `xmodel_rest.RestModel`;
        it&#39;s a RemoteModel subclass that implments a RestClient that can be used with it.
    &#34;&#34;&#34;
    client = self.structure.internal_shared_api_values.get(&#39;client&#39;)
    if client:
        return client

    client_type = get_type_hints(type(self)).get(&#39;client&#39;, None)
    if client_type is None:
        raise XModelError(
            f&#34;RemoteClient subclass type is undefined for model class ({self.model_type}), &#34;
            f&#34;a type-hint for &#39;client&#39; on BaseApi class must be in place for me to know what &#34;
            f&#34;type to get.&#34;
        )

    client = client_type(api=self.model_type.api)
    self.structure.internal_shared_api_values[&#39;client&#39;] = client
    return client</code></pre>
</details>
</dd>
<dt id="xdynamo.api.DynApi.structure"><code class="name">var <span class="ident">structure</span> : <a title="xdynamo.structure.DynStructure" href="structure.html#xdynamo.structure.DynStructure">DynStructure</a>[<a title="xdynamo.fields.DynField" href="fields.html#xdynamo.fields.DynField">DynField</a>]</code></dt>
<dd>
<div class="desc"><p>Contain things that don't vary among the model instances;
ie: This is the same object and applies to all instances of a particular BaseModel class.</p>
<p>This object has a list of <code>xmodel.fields.Field</code> that apply to the
<code>xmodel.base.model.BaseModel</code> you can get via
<code>xmodel.base.structure.Structure.fields</code>; for example.</p>
<p>This is currently created in <code>BaseApi.__init__</code>.</p>
<p>BaseApi instance for a BaseModel is only created when first asked for via
<code>xmodel.base.model.BaseModel.api</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>BaseStructure</code></dt>
<dd>Structure with correct field and model type in it.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def _structure(self):
    &#34;&#34;&#34;
    Contain things that don&#39;t vary among the model instances;
    ie: This is the same object and applies to all instances of a particular BaseModel class.

    This object has a list of `xmodel.fields.Field` that apply to the
    `xmodel.base.model.BaseModel` you can get via
    `xmodel.base.structure.Structure.fields`; for example.

    This is currently created in `BaseApi.__init__`.

    BaseApi instance for a BaseModel is only created when first asked for via
    `xmodel.base.model.BaseModel.api`.

    Returns:
        BaseStructure: Structure with correct field and model type in it.
    &#34;&#34;&#34;
    return self._structure</code></pre>
</details>
</dd>
<dt id="xdynamo.api.DynApi.table"><code class="name">var <span class="ident">table</span> : boto3.dynamodb.table.TableResource</code></dt>
<dd>
<div class="desc"><p>Returns the boto3 table resource to use for our related DynModel.
Don't cache or hang onto this, it's already properly cached for you via the current
Context and so will work in every situation [unit-tests, config-changes, etc]&hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def table(self) -&gt; TableResource:
    &#34;&#34;&#34; Returns the boto3 table resource to use for our related DynModel.
        Don&#39;t cache or hang onto this, it&#39;s already properly cached for you via the current
        Context and so will work in every situation [unit-tests, config-changes, etc]...
    &#34;&#34;&#34;

    if not self.structure.dyn_hash_key_name:
        raise XRemoteError(
            f&#34;While constructing {self.structure.model_cls}, found no hash-key field. &#34;
            f&#34;You must have at least one hash-key field.&#34;
        )

    # Look it up each time in case config/service/env/context changes enough
    # for it to be different. DynamoDB will cache the table by name and so it&#39;s
    # very fast on subsequent lookups.
    table_name = self.structure.fully_qualified_table_name()

    # noinspection PyTypeChecker
    return DynamoDB.grab().table(name=table_name, table_creator=self._create_table)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xdynamo.api.DynApi.get_key"><code class="name flex">
<span>def <span class="ident">get_key</span></span>(<span>self, hash_key: Any, range_key: Optional[Any] = None) ‑> <a title="xdynamo.common_types.DynKey" href="common_types.html#xdynamo.common_types.DynKey">DynKey</a></span>
</code></dt>
<dd>
<div class="desc"><p>Easy way to generate a basic <code>DynKey</code> with hash_key, and range_key
(if model has range key).</p>
<p>If you don't provide a range-key and the model needs a range-key,
will raise an <code>xmodel.remote.errors.XRemoteError</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_key(self, hash_key: Any, range_key: Optional[Any] = None) -&gt; DynKey:
    &#34;&#34;&#34;
    Easy way to generate a basic `DynKey` with hash_key, and range_key
    (if model has range key).

    If you don&#39;t provide a range-key and the model needs a range-key,
    will raise an `xmodel.remote.errors.XRemoteError`.
    &#34;&#34;&#34;
    return DynKey(api=self, hash_key=hash_key, range_key=range_key)</code></pre>
</details>
</dd>
<dt id="xdynamo.api.DynApi.get_via_id"><code class="name flex">
<span>def <span class="ident">get_via_id</span></span>(<span>self, id: Union[int, str, <a title="xdynamo.common_types.DynKey" href="common_types.html#xdynamo.common_types.DynKey">DynKey</a>, List[Union[int, str, <a title="xdynamo.common_types.DynKey" href="common_types.html#xdynamo.common_types.DynKey">DynKey</a>]], Dict[str, Union[str, int]], List[Dict[str, Union[str, int]]]], fields: Sequence[str] = Default, id_field: str = None, aux_query: Dict[str, Union[str, int, datetime.date, xurls.url._FormattedQueryValue, ForwardRef(None), Iterable[Union[str, int, datetime.date, xurls.url._FormattedQueryValue]]]] = None) ‑> Union[Iterable[~M], ~M, ForwardRef(None)]</span>
</code></dt>
<dd>
<div class="desc"><p>Overridden in DynApi to convert any provided <code>DynKey</code> into string-based <code>id</code> and
passing them to super and returning the result.</p>
<p>See <code>xmodel.remote.api.RemoteApi.get_via_id</code> for more details on how this method works.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong></dt>
<dd>In addition to <code>str</code> and <code>int</code> values, you can also used <code>DynKey</code>(s) if you wish.</dd>
<dt><strong><code>fields</code></strong></dt>
<dd>See <code>xmodel.remote.api.RemoteApi.get_via_id</code></dd>
<dt><strong><code>id_field</code></strong></dt>
<dd>See <code>xmodel.remote.api.RemoteApi.get_via_id</code></dd>
<dt><strong><code>aux_query</code></strong></dt>
<dd>See <code>xmodel.remote.api.RemoteApi.get_via_id</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<p>See <code>xmodel.remote.api.RemoteApi.get_via_id</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_via_id(
        self,
        id: Union[
            Union[int, str, DynKey],
            List[Union[int, str, DynKey]],
            Dict[str, Union[str, int]],
            List[Dict[str, Union[str, int]]],
        ],
        fields: FieldNames = Default,
        id_field: str = None,
        aux_query: Query = None
) -&gt; Union[Iterable[M], M, None]:
    &#34;&#34;&#34;
    Overridden in DynApi to convert any provided `DynKey` into string-based `id` and
    passing them to super and returning the result.

    See `xmodel.remote.api.RemoteApi.get_via_id` for more details on how this method works.

    Args:
        id: In addition to `str` and `int` values, you can also used `DynKey`(s) if you wish.
        fields: See `xmodel.remote.api.RemoteApi.get_via_id`
        id_field: See `xmodel.remote.api.RemoteApi.get_via_id`
        aux_query: See `xmodel.remote.api.RemoteApi.get_via_id`

    Returns:
        See `xmodel.remote.api.RemoteApi.get_via_id`
    &#34;&#34;&#34;
    if id is None:
        return None

    is_list = isinstance(id, list)
    if is_list:
        id: Union[DynKey, int, str]
        new_id = [v.id if type(v) is DynKey else v for v in xloop(id)]
    else:
        new_id = id.id if type(id) is DynKey else id

    return super().get_via_id(new_id, fields=fields, id_field=id_field, aux_query=aux_query)</code></pre>
</details>
</dd>
<dt id="xdynamo.api.DynApi.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self, **kwargs) ‑> Optional[Dict[str, Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>See <code>xmodel.base.api.BaseApi.json</code>() for docs.</p>
<p>This filters/modifies the json to make it compliant with Dynamo.
Example: Dynamo does not like blank strings as attribute values.</p>
<p>Right now this simply deletes the values out of the json dict if they are blank.
If we start doing patch-like updates [and not full puts] with dynamo, we could
easily adapt to detect when we are blanking a value so we can tell dynamo to
remove the attribute in the item during the patch-like update.</p>
<p>For now we only use full 'puts' to update dynamo items regardless of what actually
changed [we can detect changes, I would like to support this sort of thing this when
we add support for Dynamo Transactions, ie: grouping multiple creates/updates into a
single request. With a transaction, it's possible to only update specific attributes in a
dynamo row, while leaving any other attributes alone/in-tact.
(<a href="https://app.shortcut.com/xyngular/story/13989">https://app.shortcut.com/xyngular/story/13989</a>) [consolidate dynamo code]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json(self, **kwargs) -&gt; Optional[Dict[str, Any]]:
    &#34;&#34;&#34;
    See `xmodel.base.api.BaseApi.json`() for docs.

    This filters/modifies the json to make it compliant with Dynamo.
    Example: Dynamo does not like blank strings as attribute values.

    Right now this simply deletes the values out of the json dict if they are blank.
    If we start doing patch-like updates [and not full puts] with dynamo, we could
    easily adapt to detect when we are blanking a value so we can tell dynamo to
    remove the attribute in the item during the patch-like update.

    For now we only use full &#39;puts&#39; to update dynamo items regardless of what actually
    changed [we can detect changes, I would like to support this sort of thing this when
    we add support for Dynamo Transactions, ie: grouping multiple creates/updates into a
    single request. With a transaction, it&#39;s possible to only update specific attributes in a
    dynamo row, while leaving any other attributes alone/in-tact.
    (https://app.shortcut.com/xyngular/story/13989) [consolidate dynamo code]
    &#34;&#34;&#34;
    # This dict is a copy and can be mutated without a problem.
    json = super().json(**kwargs)
    if not json:
        return json

    for k in list(json.keys()):
        v = json[k]
        if isinstance(v, str) and not v:
            del json[k]

    return json</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="xdynamo" href="index.html">xdynamo</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="xdynamo.api.DynApi" href="#xdynamo.api.DynApi">DynApi</a></code></h4>
<ul class="two-column">
<li><code><a title="xdynamo.api.DynApi.client" href="#xdynamo.api.DynApi.client">client</a></code></li>
<li><code><a title="xdynamo.api.DynApi.get_key" href="#xdynamo.api.DynApi.get_key">get_key</a></code></li>
<li><code><a title="xdynamo.api.DynApi.get_via_id" href="#xdynamo.api.DynApi.get_via_id">get_via_id</a></code></li>
<li><code><a title="xdynamo.api.DynApi.json" href="#xdynamo.api.DynApi.json">json</a></code></li>
<li><code><a title="xdynamo.api.DynApi.structure" href="#xdynamo.api.DynApi.structure">structure</a></code></li>
<li><code><a title="xdynamo.api.DynApi.table" href="#xdynamo.api.DynApi.table">table</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>